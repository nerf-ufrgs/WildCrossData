---
title: "Step 7 - Check Duplicated Camera on Structure"
format: html
editor: visual
theme:
  light: flatly
  dark: superhero
---

# Problem Description

This document describes the process of identifying duplicated camera IDs within the same structure in the camera trap setup data. The goal is to ensure that each camera within a structure is uniquely identified, avoiding overlaps that could compromise data integrity.

# Problem Solving

## Common steps

We use our customized `read_sheet` function to load the camera trap setup data from all available spreadsheets. Hence, we need to load the `FUNCTIONS.R`. Another function, also needed to create unique id's called `unique_id` is loaded. Also, two special operators from the `lubridate` package are brought to the memory.

```{r}
#| label: setup

source("R/FUNCTIONS.R")

use("lubridate", c("%within%", "%--%"))
```

## Data Loading

We load the camera trap setup data (`ct`) and look for duplicated camera IDs within each structure.

```{r}
#| label: load-data
#| echo: true
#| warning: false

# Read camera trap setup data
ct <- read_sheet(sheet = "Camera_trap", na = c("NA", "na"))

ct |>
  head(2)
```

## Identifying Duplicated Cameras

We identify cases where the same camera ID appears more than once within the same structure.

```{r}
#| label: check-duplicates
#| echo: true

duplicated_cameras <- ct |> 
  purrr::map(~ .x |> 
               dplyr::count(Structure_id, Camera_id) |> 
               dplyr::filter(n > 1)) |> 
  purrr::discard(~ nrow(.x) == 0) |> 
  dplyr::bind_rows(.id = "Dataset")

duplicated_cameras |>
  head()
```

## Handling Datasets with Duplicates

We extract the datasets with duplicated cameras and apply the `unique_id` function to generate a column `Camera_id` with the new unique camera IDs. The old ID remains in `Camera_id_orig` field.

```{r}
#| label: handle-duplicates
#| echo: true

dataset_dup_cameras <- duplicated_cameras |> 
  dplyr::distinct(Dataset) |> 
  dplyr::pull(Dataset)

ct_with_dupes <- ct[names(ct) %in% dataset_dup_cameras]

ct_uniq <- ct_with_dupes |> 
  purrr::map(~ unique_id(.x))

ct_uniq |>
  head(2)
```

## Checking for Remaining Duplicates

We check if any dataset still has more than one camera ID per structure after applying the unique ID function.

```{r}
#| label: check-remaining
#| echo: true

ct_uniq |> 
  dplyr::bind_rows(.id = "Dataset") |> 
  dplyr::count(Dataset, Structure_id, Camera_id) |> 
  dplyr::filter(n > 1) |>
  head(2)
```

## Cross-checking with Species Records

We load the species records and cross-check them with the corrected camera trap data to ensure records are properly matched.

```{r}
#| label: cross-check
#| echo: true
#| warning: false

rec <- read_sheet(sheet = "Species_records_camera", na = c("NA", "na")) |> 
  purrr::map(\(x) x |> 
               dttm_update(
                 date_col = "Record_date",
                 time_col = "Record_time"
               ) |> 
               dplyr::select(-Record_time)
  ) 

rec_with_dupes <- rec[names(rec) %in% dataset_dup_cameras]

rec_with_dupes |> 
  head(2)
```

## Output Generation

For each dataset with duplicated cameras, we generate Excel files with the corrected camera trap data and the matched records. We also identify records that do not fall within any sampling interval.

```{r}
#| label: output
#| echo: true
#| warning: false

rows_with_errors <- list()

for (dataset in dataset_dup_cameras) {
  cam <- ct_uniq[[dataset]] |> 
    dplyr::mutate(code = stringr::str_glue("S{Structure_id}-C{Camera_id_orig}"))
  
  reg <- rec_with_dupes[[dataset]] |> 
    tibble::rowid_to_column("id") |> 
    dplyr::mutate(code = stringr::str_glue("S{Structure_id}-C{Camera_id}"))
  
  intermediate_result <- reg |> 
    dplyr::full_join(cam, by = "code", suffix = c("_rec", ""), relationship = "many-to-many") |> 
    dplyr::mutate(
      dplyr::across(dplyr::ends_with("_time"), ~ stringr::str_sub(., start = -8, end = -4)),
      datetime_record = Record_date,
      datetime_start = lubridate::ymd_hm(paste(
        as.character(Start_date),
        tidyr::replace_na(Start_time, "00:00")
      )),
      datetime_end = lubridate::ymd_hm(paste(
        as.character(End_date),
        tidyr::replace_na(End_time, "00:00")
      )),
      belongs_to = dplyr::if_else(
        condition = datetime_record %within% c(datetime_start %--% datetime_end),
        Camera_id,
        "nope"
      )
    )
  
  intermediate_result |> 
    dplyr::distinct(id, belongs_to, .keep_all = TRUE) |> 
    dplyr::filter(!(dplyr::n() > 1 & belongs_to == "nope"), .by = "id") |> 
    dplyr::filter(!is.na(id)) |> 
    head()
  
  rows_with_errors[[dataset]] <- intermediate_result |> 
    dplyr::filter(all(belongs_to == "nope"), .by = "id")
}

rows_with_errors |> 
  dplyr::bind_rows(.id = "dataset") |> 
  head()
```

## Results Interpretation

The output files contain:

-   Corrected camera trap data with unique camera IDs per structure.
-   Matched species records with the corrected camera IDs.
-   Records that do not fall within any camera trap sampling interval.

This process ensures data consistency and helps identify potential issues with camera deployment or data entry.
