[
  {
    "objectID": "Quarto/02_BLANK_CELLS.html",
    "href": "Quarto/02_BLANK_CELLS.html",
    "title": "4  Step 2 - Check Blank Cells",
    "section": "",
    "text": "5 Problem description\nInitially, we asked for all researchers to completely fill all sheets and cells over the file submitted. This was required for us to be sure that the authors didn’t forget to fill out some information. We asked that all cells without information should be filled with NA.",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Step 2 - Check Blank Cells</span>"
    ]
  },
  {
    "objectID": "Quarto/02_BLANK_CELLS.html#common-steps",
    "href": "Quarto/02_BLANK_CELLS.html#common-steps",
    "title": "4  Step 2 - Check Blank Cells",
    "section": "6.1 Common steps",
    "text": "6.1 Common steps\nTo solve this issue, we first load our common function file:\n\n\nCode\nsource(\"R/FUNCTIONS.R\")\n\n\nTo read the spreadsheets we run the read_sheet function that is included on our functions file. However, before doing it, we did two preliminary steps: 1) created a blank list object called list_sheet_dataset and 2) a vector object sheets with the name of all the spreadsheets that must be read sometime in our evaluations.\n\n\nCode\nlist_sheet_dataset &lt;- list()\n\nspreadsheets &lt;- c(\n  \"Underpasses\",\n  \"Overpasses\",\n  \"Fencing\",\n  \"Camera_trap\",\n  \"Species_records_camera\",\n  \"Author_data\"\n)\n\n# we read every sheet for every dataset\nfor (spreadsheet in spreadsheets) {\n\n  message(stringr::str_glue(\"\\nStarting sheet {spreadsheet}\\n\"))\n      list_sheet_dataset[[spreadsheet]] &lt;- read_sheet(\n        path = \"Excel\",\n        sheet = spreadsheet\n    )\n\n  message(stringr::str_glue(\"\\nFinalizing sheet {spreadsheet}\\n\"))\n}",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Step 2 - Check Blank Cells</span>"
    ]
  },
  {
    "objectID": "Quarto/02_BLANK_CELLS.html#checking-spreadsheets-name-consistency",
    "href": "Quarto/02_BLANK_CELLS.html#checking-spreadsheets-name-consistency",
    "title": "4  Step 2 - Check Blank Cells",
    "section": "6.2 Checking spreadsheets name consistency",
    "text": "6.2 Checking spreadsheets name consistency\nJust to be completely sure that all datasets and their respective spreadsheets had been read, we proceed counting the number of datasets and comparing then to the number of datasets found and stored in list_sheet_dataset.\n\n\nCode\nnumber_of_dataset &lt;- list.files(path = \"Excel\") |&gt;\n  length()\n\nlist_sheet_dataset |&gt;\n  purrr::map(~ length(.x) == number_of_dataset)\n\n\n$Underpasses\n[1] TRUE\n\n$Overpasses\n[1] TRUE\n\n$Fencing\n[1] TRUE\n\n$Camera_trap\n[1] TRUE\n\n$Species_records_camera\n[1] TRUE\n\n$Author_data\n[1] TRUE",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Step 2 - Check Blank Cells</span>"
    ]
  },
  {
    "objectID": "Quarto/02_BLANK_CELLS.html#finding-all-blank-sheets",
    "href": "Quarto/02_BLANK_CELLS.html#finding-all-blank-sheets",
    "title": "4  Step 2 - Check Blank Cells",
    "section": "6.3 Finding all blank sheets",
    "text": "6.3 Finding all blank sheets\nWe are going to reduce the number of levels of list_sheet_dataset from 2 to 1 using the list_flatten function. In this way we will have a large single list which their names will be a combination of the name of the spreadsheet plus the dataset.\nWe iterate each data frame and create a numerical and incremental id to the sheet. We create another index column called row that just matches the row that we see in Excel. Then, we create a column that checks if the sum of the indexes is equal to 0. If this is the case (“Uh oh!”), we only have the row that we manually inserted, meaning that the full sheet was not filled - ERROR! The result of this analysis is a vector with the name of the spreadsheets and their respective datasets.\n\n\nCode\nlist_sheet_dataset |&gt;\n  purrr::list_flatten() |&gt;\n  purrr::map(~ tibble::rowid_to_column(.x, \"id\") |&gt;\n        dplyr::add_row(id = 0) |&gt;\n        dplyr::mutate(row = id + 1,\n               in_or_out = dplyr::if_else(sum(id) == 0, \"Uh oh!\", \"OK\")) |&gt;\n        dplyr::filter(in_or_out == \"Uh oh!\") |&gt;\n        dplyr::select(row)\n  ) |&gt;\n  purrr::keep(~ nrow(.x) &gt;= 1) |&gt;\n  names()\n\n\ncharacter(0)",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Step 2 - Check Blank Cells</span>"
    ]
  },
  {
    "objectID": "Quarto/02_BLANK_CELLS.html#finding-sparse-blank-cells",
    "href": "Quarto/02_BLANK_CELLS.html#finding-sparse-blank-cells",
    "title": "4  Step 2 - Check Blank Cells",
    "section": "6.4 Finding sparse blank cells",
    "text": "6.4 Finding sparse blank cells\nFor the sake of completeness, we repeat the first part of the last process. Then, we filter for the sheets that are not completely blank (in_or_out != \"Uh oh!\") and we finally filter for all columns that have some NA cells detected. The following step consisted on keeping only the sheets/datasets that had results considering rows missing mandatory information.\n\n\nCode\ndf &lt;- list_sheet_dataset |&gt;\n  purrr::list_flatten() |&gt;\n  purrr::map(~ tibble::rowid_to_column(., \"id\") |&gt;\n        dplyr::add_row(id = 0) |&gt;\n        dplyr::mutate(row = id + 1,\n               in_or_out = dplyr::if_else(sum(id) == 0, \"Uh oh!\", \"OK\")) |&gt;\n        dplyr::filter(in_or_out != \"Uh oh!\") |&gt;\n        dplyr::filter_all(dplyr::any_vars(is.na(.))) |&gt;\n        dplyr::filter(id != 0) |&gt;\n        dplyr::select(row)\n  ) |&gt;\n  purrr::keep(~ nrow(.x) &gt;= 1)\n\ndf[1]\n\n\n$Underpasses_Alberto_Gonzalez\n# A tibble: 8 × 1\n    row\n  &lt;dbl&gt;\n1     2\n2     3\n3     4\n4     5\n5     6\n6     7\n7     8\n8     9",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Step 2 - Check Blank Cells</span>"
    ]
  },
  {
    "objectID": "Quarto/06_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html",
    "href": "Quarto/06_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html",
    "title": "8  Step 6 - Check Duplicated Camera on Structure",
    "section": "",
    "text": "9 Problem Description\nThis document describes the process of identifying duplicated camera IDs within the same structure in the camera trap setup data. The goal is to ensure that each camera within a structure is uniquely identified, avoiding overlaps that could compromise data integrity.",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Step 6 - Check Duplicated Camera on Structure</span>"
    ]
  },
  {
    "objectID": "Quarto/06_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#common-steps",
    "href": "Quarto/06_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#common-steps",
    "title": "8  Step 6 - Check Duplicated Camera on Structure",
    "section": "10.1 Common steps",
    "text": "10.1 Common steps\nWe use our customized read_sheet function to load the camera trap setup data from all available spreadsheets. Hence, we need to load the FUNCTIONS.R. Another function, also needed to create unique id’s called unique_id is loaded. Also, two special operators from the lubridate package are brought to the memory.\n\n\nCode\nsource(\"R/FUNCTIONS.R\")\n\nuse(\"lubridate\", c(\"%within%\", \"%--%\"))",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Step 6 - Check Duplicated Camera on Structure</span>"
    ]
  },
  {
    "objectID": "Quarto/06_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#data-loading",
    "href": "Quarto/06_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#data-loading",
    "title": "8  Step 6 - Check Duplicated Camera on Structure",
    "section": "10.2 Data Loading",
    "text": "10.2 Data Loading\nWe load the camera trap setup data (ct) and look for duplicated camera IDs within each structure.\n\n\nCode\n# Read camera trap setup data\nct &lt;- read_sheet(sheet = \"Camera_trap\", na = c(\"NA\", \"na\"))\n\nct |&gt;\n  head(2)\n\n\n$Alberto_Gonzalez\n# A tibble: 8 × 36\n  Structure_id Camera_id Camera_position Camera_view Camera_model   Camera_setup\n  &lt;chr&gt;        &lt;chr&gt;     &lt;chr&gt;           &lt;chr&gt;       &lt;chr&gt;          &lt;chr&gt;       \n1 PSF1         CAM63309  Interna central Interior    Pantheracam v… Secuencia d…\n2 PSF3         CAM63364  Interna central Interior    Pantheracam v… Secuencia d…\n3 PSF5         CAM63419  Interna central Interior    Pantheracam v… Secuencia d…\n4 PSF7         CAM63551  Interna central Interior    Pantheracam v… Secuencia d…\n5 PSF9         CAM63615  Interna central Interior    Pantheracam v… Secuencia d…\n6 PSF11        CAM63624  Interna central Interior    Pantheracam v… Secuencia d…\n7 PSF13        CAM63643  Interna central Interior    Pantheracam v… Secuencia d…\n8 PSF15        CAM63650  Borde interna   Interior    Pantheracam v… Secuencia d…\n# ℹ 30 more variables: Camera_vision_photo &lt;chr&gt;, Start_date &lt;dttm&gt;,\n#   Start_time &lt;dttm&gt;, End_date &lt;dttm&gt;, End_time &lt;dttm&gt;, Camera_problem &lt;chr&gt;,\n#   Problem1_from &lt;dttm&gt;, Problem1_to &lt;dttm&gt;, Problem2_from &lt;dttm&gt;,\n#   Problem2_to &lt;dttm&gt;, Problem3_from &lt;dttm&gt;, Problem3_to &lt;dttm&gt;,\n#   Problem4_from &lt;dttm&gt;, Problem4_to &lt;dttm&gt;, Problem5_from &lt;dttm&gt;,\n#   Problem5_to &lt;dttm&gt;, Problem6_from &lt;dttm&gt;, Problem6_to &lt;dttm&gt;,\n#   Problem7_from &lt;dttm&gt;, Problem7_to &lt;dttm&gt;, Problem8_from &lt;dttm&gt;, …\n\n$Ana_Delciellos\n# A tibble: 25 × 36\n   Structure_id Camera_id  Camera_position Camera_view Camera_model Camera_setup\n   &lt;chr&gt;        &lt;chr&gt;      &lt;chr&gt;           &lt;chr&gt;       &lt;chr&gt;        &lt;chr&gt;       \n 1 PNSB01       PNSB_cam1a Borda interna   Interior    Bushnell     Foto única  \n 2 PNSB01       PNSB_cam1b Borda interna   Interior    Bushnell     Foto única  \n 3 PNSB01       PNSB_cam1c Borda interna   Interior    Bushnell     Foto única  \n 4 PNSB01       PNSB_cam1d Borda interna   Interior    Bushnell     Vídeo       \n 5 PNSB01       PNSB_cam1e Borda interna   Interior    Bushnell     Foto única  \n 6 PNSB02       PNSB_cam2a Borda interna   Interior    Bushnell     Foto única  \n 7 PNSB02       PNSB_cam2b Borda interna   Interior    Bushnell     Foto única  \n 8 PNSB02       PNSB_cam2c Borda interna   Interior    Bushnell     Foto única  \n 9 PNSB03       PNSB_cam3a Borda interna   Interior    Bushnell     Foto única  \n10 PNSB03       PNSB_cam3b Borda interna   Interior    Bushnell     Foto única  \n# ℹ 15 more rows\n# ℹ 30 more variables: Camera_vision_photo &lt;chr&gt;, Start_date &lt;dttm&gt;,\n#   Start_time &lt;dttm&gt;, End_date &lt;dttm&gt;, End_time &lt;dttm&gt;, Camera_problem &lt;chr&gt;,\n#   Problem1_from &lt;dttm&gt;, Problem1_to &lt;dttm&gt;, Problem2_from &lt;dttm&gt;,\n#   Problem2_to &lt;dttm&gt;, Problem3_from &lt;dttm&gt;, Problem3_to &lt;dttm&gt;,\n#   Problem4_from &lt;dttm&gt;, Problem4_to &lt;dttm&gt;, Problem5_from &lt;dttm&gt;,\n#   Problem5_to &lt;dttm&gt;, Problem6_from &lt;dttm&gt;, Problem6_to &lt;dttm&gt;, …",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Step 6 - Check Duplicated Camera on Structure</span>"
    ]
  },
  {
    "objectID": "Quarto/06_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#identifying-duplicated-cameras",
    "href": "Quarto/06_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#identifying-duplicated-cameras",
    "title": "8  Step 6 - Check Duplicated Camera on Structure",
    "section": "10.3 Identifying Duplicated Cameras",
    "text": "10.3 Identifying Duplicated Cameras\nWe identify cases where the same camera ID appears more than once within the same structure.\n\n\nCode\nduplicated_cameras &lt;- ct |&gt; \n  purrr::map(~ .x |&gt; \n               dplyr::count(Structure_id, Camera_id) |&gt; \n               dplyr::filter(n &gt; 1)) |&gt; \n  purrr::discard(~ nrow(.x) == 0) |&gt; \n  dplyr::bind_rows(.id = \"Dataset\")\n\nduplicated_cameras |&gt;\n  head()\n\n\n# A tibble: 6 × 4\n  Dataset         Structure_id Camera_id     n\n  &lt;chr&gt;           &lt;chr&gt;        &lt;chr&gt;     &lt;int&gt;\n1 BR116_392_IBAMA B05          Cam1Ex       15\n2 BR116_392_IBAMA B05          Cam1Int      14\n3 BR116_392_IBAMA B05          Cam2Ex       15\n4 BR116_392_IBAMA B05          Cam3Ex       15\n5 EGR_data02      T1-2         camT1-2       2\n6 EGR_data02      T1-3         camT1-3       2",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Step 6 - Check Duplicated Camera on Structure</span>"
    ]
  },
  {
    "objectID": "Quarto/06_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#handling-datasets-with-duplicates",
    "href": "Quarto/06_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#handling-datasets-with-duplicates",
    "title": "8  Step 6 - Check Duplicated Camera on Structure",
    "section": "10.4 Handling Datasets with Duplicates",
    "text": "10.4 Handling Datasets with Duplicates\nWe extract the datasets with duplicated cameras and apply the unique_id function to generate a column Camera_id with the new unique camera IDs. The old ID remains in Camera_id_orig field.\n\n\nCode\ndataset_dup_cameras &lt;- duplicated_cameras |&gt; \n  dplyr::distinct(Dataset) |&gt; \n  dplyr::pull(Dataset)\n\nct_with_dupes &lt;- ct[names(ct) %in% dataset_dup_cameras]\n\nct_uniq &lt;- ct_with_dupes |&gt; \n  purrr::map(~ unique_id(.x))\n\nct_uniq |&gt;\n  head(2)\n\n\n$BR116_392_IBAMA\n# A tibble: 59 × 38\n   double Structure_id Camera_id Camera_id_orig Camera_position Camera_view\n    &lt;int&gt; &lt;chr&gt;        &lt;chr&gt;     &lt;chr&gt;          &lt;chr&gt;           &lt;chr&gt;      \n 1     15 B05          Cam1Ex_A  Cam1Ex         Externa         &lt;NA&gt;       \n 2     15 B05          Cam2Ex_A  Cam2Ex         Externa         &lt;NA&gt;       \n 3     15 B05          Cam3Ex_A  Cam3Ex         Externa         &lt;NA&gt;       \n 4     15 B05          Cam1Ex_B  Cam1Ex         Externa         &lt;NA&gt;       \n 5     15 B05          Cam2Ex_B  Cam2Ex         Externa         &lt;NA&gt;       \n 6     15 B05          Cam3Ex_B  Cam3Ex         Externa         &lt;NA&gt;       \n 7     14 B05          Cam1Int_A Cam1Int        Borda interna   Interior   \n 8     15 B05          Cam1Ex_C  Cam1Ex         Externa         &lt;NA&gt;       \n 9     15 B05          Cam2Ex_C  Cam2Ex         Externa         &lt;NA&gt;       \n10     15 B05          Cam3Ex_C  Cam3Ex         Externa         &lt;NA&gt;       \n# ℹ 49 more rows\n# ℹ 32 more variables: Camera_model &lt;chr&gt;, Camera_setup &lt;chr&gt;,\n#   Camera_vision_photo &lt;chr&gt;, Start_date &lt;dttm&gt;, Start_time &lt;dttm&gt;,\n#   End_date &lt;dttm&gt;, End_time &lt;dttm&gt;, Camera_problem &lt;chr&gt;,\n#   Problem1_from &lt;dttm&gt;, Problem1_to &lt;dttm&gt;, Problem2_from &lt;dttm&gt;,\n#   Problem2_to &lt;dttm&gt;, Problem3_from &lt;dttm&gt;, Problem3_to &lt;dttm&gt;,\n#   Problem4_from &lt;dttm&gt;, Problem4_to &lt;dttm&gt;, Problem5_from &lt;dttm&gt;, …\n\n$EGR_data02\n# A tibble: 37 × 38\n   double Structure_id Camera_id Camera_id_orig Camera_position Camera_view\n    &lt;int&gt; &lt;chr&gt;        &lt;chr&gt;     &lt;chr&gt;          &lt;chr&gt;           &lt;chr&gt;      \n 1      3 T5-6         camT5-6_A camT5-6        Borda interna   Interior   \n 2      2 T5-7         camT5-7_A camT5-7        Borda interna   Interior   \n 3      2 T5-5         camT5-5_A camT5-5        Borda interna   Interior   \n 4      3 T5-6         camT5-6_B camT5-6        Borda interna   Interior   \n 5      2 T6-2         camT6-2_A camT6-2        Borda interna   Interior   \n 6      2 T5-1         camT5-1_A camT5-1        Borda interna   Interior   \n 7      2 T5-4         camT5-4_A camT5-4        Borda interna   Interior   \n 8      2 T5-2         camT5-2_A camT5-2        Borda interna   Interior   \n 9      2 T5-3         camT5-3_A camT5-3        Borda interna   Interior   \n10      2 T3-1         camT3-1_A camT3-1        Borda interna   Interior   \n# ℹ 27 more rows\n# ℹ 32 more variables: Camera_model &lt;chr&gt;, Camera_setup &lt;chr&gt;,\n#   Camera_vision_photo &lt;chr&gt;, Start_date &lt;dttm&gt;, Start_time &lt;dttm&gt;,\n#   End_date &lt;dttm&gt;, End_time &lt;dttm&gt;, Camera_problem &lt;chr&gt;,\n#   Problem1_from &lt;dttm&gt;, Problem1_to &lt;dttm&gt;, Problem2_from &lt;dttm&gt;,\n#   Problem2_to &lt;dttm&gt;, Problem3_from &lt;dttm&gt;, Problem3_to &lt;dttm&gt;,\n#   Problem4_from &lt;dttm&gt;, Problem4_to &lt;dttm&gt;, Problem5_from &lt;dttm&gt;, …",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Step 6 - Check Duplicated Camera on Structure</span>"
    ]
  },
  {
    "objectID": "Quarto/06_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#checking-for-remaining-duplicates",
    "href": "Quarto/06_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#checking-for-remaining-duplicates",
    "title": "8  Step 6 - Check Duplicated Camera on Structure",
    "section": "10.5 Checking for Remaining Duplicates",
    "text": "10.5 Checking for Remaining Duplicates\nWe check if any dataset still has more than one camera ID per structure after applying the unique ID function.\n\n\nCode\nct_uniq |&gt; \n  dplyr::bind_rows(.id = \"Dataset\") |&gt; \n  dplyr::count(Dataset, Structure_id, Camera_id) |&gt; \n  dplyr::filter(n &gt; 1) |&gt;\n  head(2)\n\n\n# A tibble: 0 × 4\n# ℹ 4 variables: Dataset &lt;chr&gt;, Structure_id &lt;chr&gt;, Camera_id &lt;chr&gt;, n &lt;int&gt;",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Step 6 - Check Duplicated Camera on Structure</span>"
    ]
  },
  {
    "objectID": "Quarto/06_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#cross-checking-with-species-records",
    "href": "Quarto/06_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#cross-checking-with-species-records",
    "title": "8  Step 6 - Check Duplicated Camera on Structure",
    "section": "10.6 Cross-checking with Species Records",
    "text": "10.6 Cross-checking with Species Records\nWe load the species records and cross-check them with the corrected camera trap data to ensure records are properly matched.\n\n\nCode\nrec &lt;- read_sheet(sheet = \"Species_records_camera\", na = c(\"NA\", \"na\")) |&gt; \n  purrr::map(\\(x) x |&gt; \n               dttm_update(\n                 date_col = \"Record_date\",\n                 time_col = \"Record_time\"\n               ) |&gt; \n               dplyr::select(-Record_time)\n  ) \n\nrec_with_dupes &lt;- rec[names(rec) %in% dataset_dup_cameras]\n\nrec_with_dupes |&gt; \n  head(2)\n\n\n$BR116_392_IBAMA\n# A tibble: 69 × 6\n   Structure_id Camera_id Species   Record_date         Record_criteria Behavior\n   &lt;chr&gt;        &lt;chr&gt;     &lt;chr&gt;     &lt;dttm&gt;                        &lt;dbl&gt; &lt;chr&gt;   \n 1 B05          Cam1Ex    Cerdocyo… 2014-07-26 09:05:55              NA Arredor…\n 2 B05          Cam1Ex    Conepatu… 2014-07-25 23:14:18              NA Arredor…\n 3 B05          Cam1Ex    Conepatu… 2014-09-25 01:51:34              NA Arredor…\n 4 B05          Cam1Ex    Dasypus … 2014-11-27 06:36:00              NA Arredor…\n 5 B05          Cam2Ex    Cerdocyo… 2014-11-27 01:11:00              NA Arredor…\n 6 B05          Cam3Ex    Conepatu… 2014-11-27 03:07:00              NA Arredor…\n 7 B05          Cam1Int   Dasypus … 2014-11-26 02:07:00              NA Dentro  \n 8 B05          Cam1Int   Dasypus … 2014-11-27 02:18:00              NA Dentro  \n 9 B05          Cam1Int   Dasypus … 2014-11-28 00:59:00              NA Dentro  \n10 B05          Cam1Ex    Cerdocyo… 2015-01-20 02:45:55              NA Arredor…\n# ℹ 59 more rows\n\n$EGR_data02\n# A tibble: 1,178 × 6\n   Structure_id Camera_id Species   Record_date         Record_criteria Behavior\n   &lt;chr&gt;        &lt;chr&gt;     &lt;chr&gt;     &lt;dttm&gt;                        &lt;dbl&gt; &lt;chr&gt;   \n 1 T5-6         camT5-6   Didelphi… 2023-02-09 03:46:00              NA Travess…\n 2 T5-6         camT5-6   Didelphi… 2023-02-13 03:42:00              NA Travess…\n 3 T5-6         camT5-6   Didelphi… 2023-02-14 02:55:00              NA Travess…\n 4 T5-5         camT5-5   Rodentia  2023-03-08 19:57:00              NA Travess…\n 5 T5-5         camT5-5   Rodentia  2023-03-20 00:36:00              NA Travess…\n 6 T5-5         camT5-5   Rodentia  2023-03-26 22:47:00              NA Travess…\n 7 T5-6         camT5-6   Didelphi… 2023-02-17 01:24:00              NA Travess…\n 8 T5-6         camT5-6   Didelphi… 2023-02-18 01:15:00              NA Travess…\n 9 T5-6         camT5-6   Didelphi… 2023-02-25 00:05:00              NA Travess…\n10 T5-6         camT5-6   Didelphi… 2023-02-26 04:14:00              NA Travess…\n# ℹ 1,168 more rows",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Step 6 - Check Duplicated Camera on Structure</span>"
    ]
  },
  {
    "objectID": "Quarto/06_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#output-generation",
    "href": "Quarto/06_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#output-generation",
    "title": "8  Step 6 - Check Duplicated Camera on Structure",
    "section": "10.7 Output Generation",
    "text": "10.7 Output Generation\nFor each dataset with duplicated cameras, we generate Excel files with the corrected camera trap data and the matched records. We also identify records that do not fall within any sampling interval.\n\n\nCode\nrows_with_errors &lt;- list()\n\nfor (dataset in dataset_dup_cameras) {\n  cam &lt;- ct_uniq[[dataset]] |&gt; \n    dplyr::mutate(code = stringr::str_glue(\"S{Structure_id}-C{Camera_id_orig}\"))\n  \n  reg &lt;- rec_with_dupes[[dataset]] |&gt; \n    tibble::rowid_to_column(\"id\") |&gt; \n    dplyr::mutate(code = stringr::str_glue(\"S{Structure_id}-C{Camera_id}\"))\n  \n  intermediate_result &lt;- reg |&gt; \n    dplyr::full_join(cam, by = \"code\", suffix = c(\"_rec\", \"\"), relationship = \"many-to-many\") |&gt; \n    dplyr::mutate(\n      dplyr::across(dplyr::ends_with(\"_time\"), ~ stringr::str_sub(., start = -8, end = -4)),\n      datetime_record = Record_date,\n      datetime_start = lubridate::ymd_hm(paste(\n        as.character(Start_date),\n        tidyr::replace_na(Start_time, \"00:00\")\n      )),\n      datetime_end = lubridate::ymd_hm(paste(\n        as.character(End_date),\n        tidyr::replace_na(End_time, \"00:00\")\n      )),\n      belongs_to = dplyr::if_else(\n        condition = datetime_record %within% c(datetime_start %--% datetime_end),\n        Camera_id,\n        \"nope\"\n      )\n    )\n  \n  intermediate_result |&gt; \n    dplyr::distinct(id, belongs_to, .keep_all = TRUE) |&gt; \n    dplyr::filter(!(dplyr::n() &gt; 1 & belongs_to == \"nope\"), .by = \"id\") |&gt; \n    dplyr::filter(!is.na(id)) |&gt; \n    head()\n  \n  rows_with_errors[[dataset]] &lt;- intermediate_result |&gt; \n    dplyr::filter(all(belongs_to == \"nope\"), .by = \"id\")\n}\n\nrows_with_errors |&gt; \n  dplyr::bind_rows(.id = \"dataset\") |&gt; \n  head()\n\n\n# A tibble: 6 × 51\n  dataset          id Structure_id_rec Camera_id_rec Species Record_date        \n  &lt;chr&gt;         &lt;int&gt; &lt;chr&gt;            &lt;chr&gt;         &lt;chr&gt;   &lt;dttm&gt;             \n1 BR116_392_IB…     1 B05              Cam1Ex        Cerdoc… 2014-07-26 09:05:55\n2 BR116_392_IB…     1 B05              Cam1Ex        Cerdoc… 2014-07-26 09:05:55\n3 BR116_392_IB…     1 B05              Cam1Ex        Cerdoc… 2014-07-26 09:05:55\n4 BR116_392_IB…     1 B05              Cam1Ex        Cerdoc… 2014-07-26 09:05:55\n5 BR116_392_IB…     1 B05              Cam1Ex        Cerdoc… 2014-07-26 09:05:55\n6 BR116_392_IB…     1 B05              Cam1Ex        Cerdoc… 2014-07-26 09:05:55\n# ℹ 45 more variables: Record_criteria &lt;dbl&gt;, Behavior &lt;chr&gt;, code &lt;glue&gt;,\n#   double &lt;int&gt;, Structure_id &lt;chr&gt;, Camera_id &lt;chr&gt;, Camera_id_orig &lt;chr&gt;,\n#   Camera_position &lt;chr&gt;, Camera_view &lt;chr&gt;, Camera_model &lt;chr&gt;,\n#   Camera_setup &lt;chr&gt;, Camera_vision_photo &lt;chr&gt;, Start_date &lt;dttm&gt;,\n#   Start_time &lt;chr&gt;, End_date &lt;dttm&gt;, End_time &lt;chr&gt;, Camera_problem &lt;chr&gt;,\n#   Problem1_from &lt;dttm&gt;, Problem1_to &lt;dttm&gt;, Problem2_from &lt;dttm&gt;,\n#   Problem2_to &lt;dttm&gt;, Problem3_from &lt;dttm&gt;, Problem3_to &lt;dttm&gt;, …",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Step 6 - Check Duplicated Camera on Structure</span>"
    ]
  },
  {
    "objectID": "Quarto/06_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#results-interpretation",
    "href": "Quarto/06_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#results-interpretation",
    "title": "8  Step 6 - Check Duplicated Camera on Structure",
    "section": "10.8 Results Interpretation",
    "text": "10.8 Results Interpretation\nThe output files contain:\n\nCorrected camera trap data with unique camera IDs per structure.\nMatched species records with the corrected camera IDs.\nRecords that do not fall within any camera trap sampling interval.\n\nThis process ensures data consistency and helps identify potential issues with camera deployment or data entry.",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Step 6 - Check Duplicated Camera on Structure</span>"
    ]
  },
  {
    "objectID": "Quarto/00_PRESENTATION_FUNCTIONS.html",
    "href": "Quarto/00_PRESENTATION_FUNCTIONS.html",
    "title": "2  Step 0 - Creating customized functions",
    "section": "",
    "text": "3 Presentation\nBlabla",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Step 0 - Creating customized functions</span>"
    ]
  },
  {
    "objectID": "Quarto/01_COLUMN_CONSISTENCY.html",
    "href": "Quarto/01_COLUMN_CONSISTENCY.html",
    "title": "3  Step 1 - Check Column Consistency",
    "section": "",
    "text": "4 Problem description\nThe idea behind this was simply to bind rows of every spreadsheet and check for warnings and errors. If column types were different errors had to be risen and formats would be subject of warnings.\nThe first step of checking the spreadsheets consisted in trying to read all of them and binding their rows. By doing this, if the column type was not the same, we then had to set the columns with the same type. Also, by reading each spreadsheet, read_excel may warns us if something is wrong.\n\n\n5 Problem solving\nWe defined for each column over the 5 spreadsheets which type all of them were. We populated a table directly in Excel and then we read using the following commands:\n\n\nCode\ncol_types &lt;- list()\n\npath &lt;- \"support/column_types.xlsx\"\n\nsheet_names &lt;- readxl::excel_sheets(path)\n\nfor (i in 1:length(sheet_names)) {\n  col_types[[sheet_names[i]]] &lt;- readxl::read_excel(path = path, sheet = i)\n}\n\n# Showing an example of the output\ncol_types[1]\n\n\n$Underpasses\n# A tibble: 17 × 2\n   Column              Type   \n   &lt;chr&gt;               &lt;chr&gt;  \n 1 Infrastructure_type text   \n 2 Structure_ID        text   \n 3 Structure_type      text   \n 4 Structure_cell      text   \n 5 Structure_shape     text   \n 6 Structure_photo     text   \n 7 Structure_age       numeric\n 8 Structure_height    numeric\n 9 Structure_length    numeric\n10 Structure_width     numeric\n11 Waterbody_width     numeric\n12 Latitude            numeric\n13 Longitude           numeric\n14 UTM Zone            text   \n15 X (Easting)         numeric\n16 Y (Northing)        numeric\n17 Datum               text   \n\n\nThe following process has to be repeated for all the spreadsheets, however here we illustrate using the “Underpasses” spreadsheet. In order to collect the messages provided by R we adapted the read_excel function with a purrr::quietly function, that is more appropriate to show warnings and messages for each file/author. We enchain the customized read_sheet function that provides the full paths of all .xlsx files available to the purrr::quietly function.\nIn the sequence, we are able to collect the warnings (in this case, under_warns), check and correct them directly on the Excel files. The majority of the errors are misspelled text, decimal markers, date and time separators and so on…\nAfter we zeroing the warnings, we are able to check if R successfully bind the rows from each author. If no warnings or errors are raised, it means that we reached our goal.\n\n\nCode\n#Underpasses ----\nsource(\"R/FUNCTIONS.R\")\n\nunder_q &lt;- purrr::quietly(function(file){\n  readxl::read_excel(\n    file,\n    col_types = col_types[[\"Underpasses\"]]$Type,\n    sheet = \"Underpasses\",\n    na = c(\"NA\", \"na\"),\n    col_names = TRUE\n  ) |&gt;\n    janitor::remove_empty(\"rows\")\n})\n\nunder_all_outputs &lt;- read_sheet(path = \"Excel\", results = FALSE) |&gt;\n  purrr::map(under_q)\n\nunder_warns &lt;- under_all_outputs |&gt;\n  purrr::map(\\(x) purrr::pluck(x, \"warnings\")) |&gt;\n  purrr::compact()\n\nunder_results &lt;- under_all_outputs |&gt;\n  purrr::map(\\(x) purrr::pluck(x, \"result\")) |&gt;\n  dplyr::bind_rows(.id = \"Dataset\")\n\nunder_results |&gt;\n  print(n = 10)\n\n\n# A tibble: 357 × 20\n   Dataset        Infrastructure_type Structure_ID Structure_type Structure_cell\n   &lt;chr&gt;          &lt;chr&gt;               &lt;chr&gt;        &lt;chr&gt;          &lt;chr&gt;         \n 1 Alberto_Gonza… Carretera           PSF1         Paso de fauna  1             \n 2 Alberto_Gonza… Carretera           PSF3         Paso de fauna  3             \n 3 Alberto_Gonza… Carretera           PSF5         Paso de fauna  5             \n 4 Alberto_Gonza… Carretera           PSF7         Paso de fauna  7             \n 5 Alberto_Gonza… Carretera           PSF9         Paso de fauna  9             \n 6 Alberto_Gonza… Carretera           PSF11        Paso de fauna  11            \n 7 Alberto_Gonza… Carretera           PSF13        Paso de fauna  13            \n 8 Alberto_Gonza… Carretera           PSF15        Paso de fauna  15            \n 9 Ana_Delciellos Rodovia             PNSB01       Passagem de f… 1             \n10 Ana_Delciellos Rodovia             PNSB02       Passagem de f… 1             \n# ℹ 347 more rows\n# ℹ 15 more variables: Structure_shape &lt;chr&gt;, Structure_photo &lt;chr&gt;,\n#   Structure_age &lt;dbl&gt;, Structure_height &lt;dbl&gt;, Structure_length &lt;dbl&gt;,\n#   Structure_width &lt;dbl&gt;, Waterbody_width &lt;dbl&gt;, Latitude &lt;dbl&gt;,\n#   Longitude &lt;dbl&gt;, `UTM Zone` &lt;chr&gt;, `X (Easting)` &lt;dbl&gt;,\n#   `Y (Northing)` &lt;dbl&gt;, Datum &lt;chr&gt;, Structure_lenght &lt;dbl&gt;,\n#   structure_length &lt;dbl&gt;",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Step 1 - Check Column Consistency</span>"
    ]
  },
  {
    "objectID": "Quarto/03_CHECK_SPECIES.html",
    "href": "Quarto/03_CHECK_SPECIES.html",
    "title": "5  Step 3 - Check Species Validity",
    "section": "",
    "text": "6 Problem description\nIn databases it is frequent to have a species taxa list. Since most of the lists are filled by humans it is expected that the taxa names have typos and different styles of determining unindentified species notation. In that sense it is necessary to check and correct the taxa name using services specifics to that end.\nSince we’re checking crossings obtained by camera traps it is normal that some taxa couldn’t be identified in species level. This represents a more difficult approach as we have to consider the lowest possible taxonomic level. In this context we have to have solutions that tackle the validity of several ways of filling the species field.",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Step 3 - Check Species Validity</span>"
    ]
  },
  {
    "objectID": "Quarto/03_CHECK_SPECIES.html#common-steps",
    "href": "Quarto/03_CHECK_SPECIES.html#common-steps",
    "title": "5  Step 3 - Check Species Validity",
    "section": "7.1 Common steps",
    "text": "7.1 Common steps\nTo solve this issue, we follow some of the first basic steps from previous checks, as using our customized read_sheet function that provides the full paths of all .xlsx files available in order to read the species sheet from all files.\n\n\nCode\nsource(\"R/FUNCTIONS.R\")\n\n\n\n\nCode\nspreadsheets &lt;- read_sheet(path = \"Excel\", results = FALSE)\n\nsp_full &lt;- purrr::map(.x = spreadsheets, function(arquivo){\n  readxl::read_excel(\n    arquivo,\n    sheet = 6,\n    na = c(\"NA\", \"na\"),\n    col_types = c(\"guess\", \"guess\", \"guess\", \"date\", \"guess\", \"guess\", \"guess\"),\n    col_names = TRUE\n  )\n})\n\n\nWarning: Expecting date in D2996 / R2996C4: got 'xx/07/2019'\n\n\nWarning: Expecting date in D2997 / R2997C4: got 'xx/07/2019'\n\n\nWarning: Expecting date in D2998 / R2998C4: got 'xx/07/2019'\n\n\nWarning: Expecting date in D2999 / R2999C4: got 'xx/07/2019'\n\n\nWarning: Expecting date in D3000 / R3000C4: got 'xx/07/2019'\n\n\nWarning: Expecting date in D3001 / R3001C4: got 'xx/07/2019'\n\n\nWarning: Expecting date in D3002 / R3002C4: got 'xx/07/2019'\n\n\nCode\nhead(sp_full[1][[1]]) # show head of first file\n\n\n# A tibble: 6 × 7\n  Structure_ID Camera_ID Species         Record_date         Record_time        \n  &lt;chr&gt;        &lt;chr&gt;     &lt;chr&gt;           &lt;dttm&gt;              &lt;dttm&gt;             \n1 PSF2         CAM63309  Homo sapiens    2017-10-26 00:00:00 1899-12-31 15:05:00\n2 PSF1         CAM63309  Urocyon cinere… 2017-12-13 00:00:00 1899-12-31 00:53:00\n3 PSF3         CAM63309  Homo sapiens    2018-03-14 00:00:00 1899-12-31 11:04:00\n4 PSF1         CAM63309  Chiroptera      2018-04-16 00:00:00 1899-12-31 20:54:00\n5 PSF1         CAM63309  Chiroptera      2018-04-17 00:00:00 1899-12-31 01:24:00\n6 PSF1         CAM63309  Chiroptera      2018-04-17 00:00:00 1899-12-31 02:45:00\n# ℹ 2 more variables: Record_criteria &lt;dbl&gt;, Behavior &lt;chr&gt;",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Step 3 - Check Species Validity</span>"
    ]
  },
  {
    "objectID": "Quarto/03_CHECK_SPECIES.html#specific-steps",
    "href": "Quarto/03_CHECK_SPECIES.html#specific-steps",
    "title": "5  Step 3 - Check Species Validity",
    "section": "7.2 Specific steps",
    "text": "7.2 Specific steps\n\n7.2.1 Full species\nWe first start keeping only valid (full) species. In this sense, we are considering only two-worded terms that doesn’t have sp, spp, ni and similars, which are commonly used to designate unidentified species.\n\n\nCode\nspecies_all_check &lt;- sp_full |&gt;\n  purrr::map(function(x) {\n    x |&gt;\n      dplyr::distinct(Species) |&gt;  # unique values for Species\n      dplyr::mutate(Species = stringr::str_squish(Species)) |&gt; # remove whitespaces\n      dplyr::filter(\n        stringr::str_count(Species, \" \") == 1,\n        !stringr::str_detect(stringr::word(Species, 2, 2), \"\\\\.\"),\n        !stringr::str_detect(stringr::word(Species, 2, 2), \"^sp$\"),\n        !stringr::str_detect(stringr::word(Species, 2, 2), \"^sp(?=\\\\.)\"),\n        !stringr::str_detect(stringr::word(Species, 2, 2), \"^spp(?=\\\\.)\"),\n        !stringr::str_detect(stringr::word(Species, 2, 2), \"\\\\(\"),\n        !stringr::str_detect(stringr::word(Species, 2, 2), \"^ni$\"),\n        !stringr::str_detect(stringr::word(Species, 2, 2), \"^NI$\"),\n        !stringr::str_detect(stringr::word(Species, 2, 2), \"^NID$\"),\n        !stringr::str_detect(Species, \"\\\\/\")\n      ) |&gt;\n      dplyr::arrange(Species) |&gt; # alphabetical order\n      dplyr::pull() # vector\n  })\n\nhead(species_all_check[1][[1]]) # show head of first list\n\n\n[1] \"Canis familiaris\"    \"Cuniculus paca\"      \"Dasyprocta punctata\"\n[4] \"Eira barbara\"        \"Homo sapiens\"        \"Meleagris ocellata\" \n\n\nSince there is a chance that some of the species name have multiple types of spelling considering trailing spaces, we check for names that are similar.\n\n\nCode\nspecies_all_check |&gt;\n  purrr::map(function(x){\n    table &lt;- table(x)\n\n    table[table &gt; 1]\n  }) |&gt;\n  purrr::keep(~ any(.x &gt; 1))\n\n\nnamed list()\n\n\nHaving the full species list, we use the Global Names Verifier API (https://verifier.globalnames.org/) to check the species names. We opted to do it through Integrated Taxonomic Information System (ITIS) which is data source = 3 on the address for the API. We use the package httr to help on checking the API.\nFor each dataset, we checked all full species names. By the end of the code chunk, we unnested the columns bestResult and scoreDetails that come originally as a data frame from the Global Names Verifier. Following this procedure, we compiled the species results in a single data frame for all species for each dataset.\n\n\nCode\nlist_check_globalnames &lt;- list()\n\nfor (dataset in names(species_all_check)) {\n\n  species &lt;- species_all_check[[dataset]]\n\n  message(stringr::str_glue(\"Starting dataset {dataset}\"))\n\n  for (sp in species) {\n    sp_ &lt;- stringr::str_replace(sp, \" \", \"_\")\n\n    result &lt;- httr::GET(stringr::str_glue(\"https://verifier.globalnames.org/api/v1/verifications/{sp_}?data_sources=3\")) # the link for the API check\n\n    list_check_globalnames[[dataset]][[sp_]] &lt;- jsonlite::fromJSON(rawToChar(result$content))[[\"names\"]] # save the part that interests us on a list composed by the dataset and the species name\n  }\n  # bind the species list on a single data frame unnesting the columns that are a data frame\n  list_check_globalnames[[dataset]][[\"all_results\"]] &lt;- list_check_globalnames[[dataset]] |&gt;\n    dplyr::bind_rows() |&gt;\n    tidyr::unnest(cols = c(bestResult), names_repair = \"unique\") |&gt;\n    tidyr::unnest(cols = c(scoreDetails), names_repair = \"unique\") |&gt;\n    tibble::as_tibble()\n}\n\nlist_check_globalnames[[1]][[\"all_results\"]]\n\n\n# A tibble: 10 × 40\n   id          name  cardinality matchType...4 dataSourceId dataSourceTitleShort\n   &lt;chr&gt;       &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;                &lt;int&gt; &lt;chr&gt;               \n 1 1f6805ff-9… Cani…           2 Exact                    3 ITIS                \n 2 3b28ba6f-d… Cuni…           2 Exact                    3 ITIS                \n 3 f9c5dc3d-1… Dasy…           2 Exact                    3 ITIS                \n 4 510380ef-b… Eira…           2 Exact                    3 ITIS                \n 5 bc81c617-d… Homo…           2 Exact                    3 ITIS                \n 6 91cac633-b… Mele…           2 Exact                    3 ITIS                \n 7 51c9b515-3… Nasu…           2 Exact                    3 ITIS                \n 8 b8368875-0… Pant…           2 Exact                    3 ITIS                \n 9 a5261dbc-4… Puma…           2 Exact                    3 ITIS                \n10 feb4010c-8… Uroc…           2 Exact                    3 ITIS                \n# ℹ 34 more variables: curation...7 &lt;chr&gt;, recordId &lt;chr&gt;, outlink &lt;chr&gt;,\n#   entryDate &lt;chr&gt;, sortScore &lt;dbl&gt;, matchedNameID &lt;chr&gt;, matchedName &lt;chr&gt;,\n#   matchedCardinality &lt;int&gt;, matchedCanonicalSimple &lt;chr&gt;,\n#   matchedCanonicalFull &lt;chr&gt;, currentRecordId &lt;chr&gt;, currentNameId &lt;chr&gt;,\n#   currentName &lt;chr&gt;, currentCardinality &lt;int&gt;, currentCanonicalSimple &lt;chr&gt;,\n#   currentCanonicalFull &lt;chr&gt;, taxonomicStatus &lt;chr&gt;, isSynonym &lt;lgl&gt;,\n#   classificationPath &lt;chr&gt;, classificationRanks &lt;chr&gt;, …\n\n\nThe next step consisted in creating a full data frame of all the species from all the datasets. We mapped the all_results list from each dataset and then stacked them on a single data frame.\n\n\nCode\nlist_sp &lt;- list_check_globalnames |&gt;\n  purrr::map(\"all_results\") |&gt;\n  dplyr::bind_rows(.id = \"dataset\") |&gt;\n  janitor::clean_names() |&gt;\n  dplyr::mutate(query = stringr::str_replace_all(name, \"_\", \" \"), .after = name)\n\nhead(list_sp)\n\n\n# A tibble: 6 × 42\n  dataset          id        name  query cardinality match_type_4 data_source_id\n  &lt;chr&gt;            &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;                 &lt;int&gt;\n1 Alberto_Gonzalez 1f6805ff… Cani… Cani…           2 Exact                     3\n2 Alberto_Gonzalez 3b28ba6f… Cuni… Cuni…           2 Exact                     3\n3 Alberto_Gonzalez f9c5dc3d… Dasy… Dasy…           2 Exact                     3\n4 Alberto_Gonzalez 510380ef… Eira… Eira…           2 Exact                     3\n5 Alberto_Gonzalez bc81c617… Homo… Homo…           2 Exact                     3\n6 Alberto_Gonzalez 91cac633… Mele… Mele…           2 Exact                     3\n# ℹ 35 more variables: data_source_title_short &lt;chr&gt;, curation_7 &lt;chr&gt;,\n#   record_id &lt;chr&gt;, outlink &lt;chr&gt;, entry_date &lt;chr&gt;, sort_score &lt;dbl&gt;,\n#   matched_name_id &lt;chr&gt;, matched_name &lt;chr&gt;, matched_cardinality &lt;int&gt;,\n#   matched_canonical_simple &lt;chr&gt;, matched_canonical_full &lt;chr&gt;,\n#   current_record_id &lt;chr&gt;, current_name_id &lt;chr&gt;, current_name &lt;chr&gt;,\n#   current_cardinality &lt;int&gt;, current_canonical_simple &lt;chr&gt;,\n#   current_canonical_full &lt;chr&gt;, taxonomic_status &lt;chr&gt;, is_synonym &lt;lgl&gt;, …\n\n\nSince we want only the errors, we filtered the column match_type_4 to show every row in which the result was not “Exact”. That means that every species in which the query and the result was not the exact same term were selected to further evaluation.\n\n\nCode\nsp_with_errors &lt;- list_sp |&gt;\n  dplyr::filter(match_type_4 != \"Exact\")\n\nhead(sp_with_errors)\n\n\n# A tibble: 6 × 42\n  dataset           id       name  query cardinality match_type_4 data_source_id\n  &lt;chr&gt;             &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;                 &lt;int&gt;\n1 Ana_Delciellos    46334ff… Guer… Guer…           2 PartialExact              3\n2 Diego_Varela      46334ff… Guer… Guer…           2 PartialExact              3\n3 Diego_Varela      fa20ddb… Maza… Maza…           2 PartialExact              3\n4 Diego_Varela      ca56c67… Sylv… Sylv…           2 PartialExact              3\n5 EcoRioMinas_IBAMA 46334ff… Guer… Guer…           2 PartialExact              3\n6 EricaSaito        c6eeb58… Dico… Dico…           2 PartialExact              3\n# ℹ 35 more variables: data_source_title_short &lt;chr&gt;, curation_7 &lt;chr&gt;,\n#   record_id &lt;chr&gt;, outlink &lt;chr&gt;, entry_date &lt;chr&gt;, sort_score &lt;dbl&gt;,\n#   matched_name_id &lt;chr&gt;, matched_name &lt;chr&gt;, matched_cardinality &lt;int&gt;,\n#   matched_canonical_simple &lt;chr&gt;, matched_canonical_full &lt;chr&gt;,\n#   current_record_id &lt;chr&gt;, current_name_id &lt;chr&gt;, current_name &lt;chr&gt;,\n#   current_cardinality &lt;int&gt;, current_canonical_simple &lt;chr&gt;,\n#   current_canonical_full &lt;chr&gt;, taxonomic_status &lt;chr&gt;, is_synonym &lt;lgl&gt;, …\n\n\nAfter checking the list of species considered not “Exact”, we found that some species that were not “Exact” must be whitelisted, since we are sure that the name is valid (for example, checking the List of Brazilian Mammals from the Brazilian Mastozoological Society). They can be appended to the names that were considered as “Exact”. This is the last step for the “Full species” inspection.\n\n\nCode\nsp_whitelist &lt;- list_sp |&gt;\n  dplyr::filter(match_type_4 == \"Exact\") |&gt;\n  dplyr::pull(query) |&gt;\n  append(c(\"Guerlinguetus brasiliensis\", \"Guerlinguetus ingrami\")) |&gt; # manually insert species that we know that are correct but the API don't think they are.\n  unique() |&gt;\n  sort()\n\nhead(sp_whitelist)\n\n\n[1] \"Alouatta guariba\"        \"Alouatta macconnelli\"   \n[3] \"Amazonetta brasiliensis\" \"Ameiva ameiva\"          \n[5] \"Aotus nigriceps\"         \"Aphelocoma wollweberi\"  \n\n\n\n\n7.2.2 Imprecise taxa\nFirst of all we have to filter for the species that were not on the query for full species - meaning that all of the terms that were not considered as full species still have to be evaluated.\n\n\nCode\nnon_species_all_check &lt;- purrr::map2(sp_full, species_all_check, function(x, y){\n  x |&gt;\n    dplyr::distinct(Species) |&gt;\n    dplyr::mutate(Species = stringr::str_squish(Species)) |&gt;\n    dplyr::pull(Species) |&gt;\n    setdiff(y)\n}) |&gt;\n  purrr::compact()\n\nhead(non_species_all_check[[1]])\n\n\n[1] \"Chiroptera\"    \"Passeriformes\" \"Didelphis sp.\" \"Momotus sp.\"  \n\n\nWe perform the same approach as we did for the full species, this time for the terms that are not full. By the end, we create a data frame that comprises all terms that were not considered as “Exact” on the query from the API, as well as queries that involved terms as “NI” or “spp”.\n\n\nCode\nlist_non_sp_with_errors &lt;- list()\n\nfor (dataset in names(non_species_all_check)) {\n\n  species &lt;- non_species_all_check[[dataset]]\n\n  message(stringr::str_glue(\"Starting dataset {dataset}\"))\n\n  for (sp in species) {\n    sp_ &lt;- sp |&gt;\n      stringr::str_remove_all(\"[[:punct:]]\") |&gt;\n      stringr::str_replace_all(pattern = \" \", replacement = \"_\")\n\n    result &lt;- httr::GET(stringr::str_glue(\"https://verifier.globalnames.org/api/v1/verifications/{sp_}?data_sources=3\")) # the link for the API check\n\n    list_non_sp_with_errors[[dataset]][[sp_]] &lt;- jsonlite::fromJSON(rawToChar(result$content))[[\"names\"]] # save the part that interests us on a list composed by the dataset and the species name\n  }\n  # bind the species list on a single data frame unnesting the columns that are a data frame\n  list_non_sp_with_errors[[dataset]][[\"all_results\"]] &lt;- list_non_sp_with_errors[[dataset]] |&gt;\n    dplyr::bind_rows() |&gt;\n    tibble::as_tibble()\n}\n\nnon_sp_with_errors &lt;- list_non_sp_with_errors |&gt;\n  purrr::map(\"all_results\") |&gt;\n  dplyr::bind_rows(.id = \"dataset\") |&gt;\n  janitor::clean_names() |&gt;\n  dplyr::mutate(query = stringr::str_replace_all(name, \"_\", \" \"), .after = name)\n\nhead(non_sp_with_errors)\n\n\n# A tibble: 6 × 10\n  dataset        id    name  query cardinality match_type best_result$dataSour…¹\n  &lt;chr&gt;          &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;                       &lt;int&gt;\n1 Alberto_Gonza… af14… Chir… Chir…           1 Exact                           3\n2 Alberto_Gonza… 22da… Pass… Pass…           1 Exact                           3\n3 Alberto_Gonza… 79ee… Dide… Dide…           0 Exact                           3\n4 Alberto_Gonza… 04e6… Momo… Momo…           0 Exact                           3\n5 Ana_Delciellos 9fd2… Mamm… Mamm…           1 Exact                           3\n6 Ana_Delciellos 2806… Aves  Aves            1 Exact                           3\n# ℹ abbreviated name: ¹​best_result$dataSourceId\n# ℹ 29 more variables: best_result$dataSourceTitleShort &lt;chr&gt;, $curation &lt;chr&gt;,\n#   $recordId &lt;chr&gt;, $outlink &lt;chr&gt;, $entryDate &lt;chr&gt;, $sortScore &lt;dbl&gt;,\n#   $matchedNameID &lt;chr&gt;, $matchedName &lt;chr&gt;, $matchedCardinality &lt;int&gt;,\n#   $matchedCanonicalSimple &lt;chr&gt;, $matchedCanonicalFull &lt;chr&gt;,\n#   $currentRecordId &lt;chr&gt;, $currentNameId &lt;chr&gt;, $currentName &lt;chr&gt;,\n#   $currentCardinality &lt;int&gt;, $currentCanonicalSimple &lt;chr&gt;, …\n\n\nThe last step is to put together a full list of problems/errors independently if they are for full species or imprecise taxa. In this step we use the sp_whitelist to escape this terms that we think are correct.\n\n\nCode\nsp_with_errors |&gt;\n  dplyr::select(dataset, query, matched_canonical_simple, match_type = match_type_4) |&gt;\n  dplyr::filter(!query %in% sp_whitelist) |&gt;\n  dplyr::bind_rows(non_sp_with_errors) |&gt;\n  dplyr::arrange(dataset)\n\n\n# A tibble: 221 × 11\n   dataset       query matched_canonical_si…¹ match_type id    name  cardinality\n   &lt;chr&gt;         &lt;chr&gt; &lt;chr&gt;                  &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt;       &lt;int&gt;\n 1 Alberto_Gonz… Chir… &lt;NA&gt;                   Exact      af14… Chir…           1\n 2 Alberto_Gonz… Pass… &lt;NA&gt;                   Exact      22da… Pass…           1\n 3 Alberto_Gonz… Dide… &lt;NA&gt;                   Exact      79ee… Dide…           0\n 4 Alberto_Gonz… Momo… &lt;NA&gt;                   Exact      04e6… Momo…           0\n 5 Ana_Delciell… Mamm… &lt;NA&gt;                   Exact      9fd2… Mamm…           1\n 6 Ana_Delciell… Aves  &lt;NA&gt;                   Exact      2806… Aves            1\n 7 Ana_Delciell… Leop… &lt;NA&gt;                   Exact      12ee… Leop…           0\n 8 Ana_Delciell… Dasy… &lt;NA&gt;                   Exact      1f77… Dasy…           0\n 9 Arteris_Lito… Aram… &lt;NA&gt;                   Exact      2c8c… Aram…           0\n10 Arteris_Lito… Rode… &lt;NA&gt;                   Exact      d91e… Rode…           1\n# ℹ 211 more rows\n# ℹ abbreviated name: ¹​matched_canonical_simple\n# ℹ 4 more variables: best_result &lt;df[,27]&gt;, data_sources_num &lt;int&gt;,\n#   data_sources_ids &lt;list&gt;, curation &lt;chr&gt;",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Step 3 - Check Species Validity</span>"
    ]
  },
  {
    "objectID": "Quarto/04_CHECK_STRUCTURE.html",
    "href": "Quarto/04_CHECK_STRUCTURE.html",
    "title": "6  Step 4 - Check Structures",
    "section": "",
    "text": "7 Problem description\nWe must check if the camera trap Structure_id provided on the sheet Camera_trap is encompassed on the sheets that describe the structures (Underpasses and Overpasses). These sheets also possess the Structure_id field. This column is the link between Camera_trap and Underpasses / Overpasses.\nAll the listed Structure_id provided on the Camera_trap sheet must be present on either Underpasses or Overpasses. The opposite direction is also true, meaning that all the Structure_id provided either on Underpasses or Overpasses must be comprised on Camera_trap.\nWe also have to evaluate if the Structure_id present in the Fencing spreadsheet is included on the Underpasses spreadsheet. We are assuming that there are no fencing for Overpasses.",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Step 4 - Check Structures</span>"
    ]
  },
  {
    "objectID": "Quarto/04_CHECK_STRUCTURE.html#common-steps",
    "href": "Quarto/04_CHECK_STRUCTURE.html#common-steps",
    "title": "6  Step 4 - Check Structures",
    "section": "8.1 Common steps",
    "text": "8.1 Common steps\nTo solve this issue, we follow some of the first basic steps from previous checks, as using our customized read_sheet function that provides the full paths of all .xlsx files available in order to read the species sheet from all files.\n\n\nCode\nsource(\"R/FUNCTIONS.R\")\n\n\nHere we read the camera trap sheet from all files. We opted to bring the elements of the structures (field Structure_id) to upper case in order to avoid confusions. We also decided do keep only the column Structure_id by using the argument .keep.\n\n\nCode\nct &lt;- read_sheet(path = \"Excel\",\n                 sheet = \"Camera_trap\",\n                    na = c(\"\", \"na\", \"NA\")) |&gt;\n  purrr::map(~ .x |&gt;\n               dplyr::mutate(\n                 Structure_id = as.character(stringr::str_to_upper(Structure_id)),\n                 .keep = \"none\"\n               ))",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Step 4 - Check Structures</span>"
    ]
  },
  {
    "objectID": "Quarto/04_CHECK_STRUCTURE.html#specific-steps",
    "href": "Quarto/04_CHECK_STRUCTURE.html#specific-steps",
    "title": "6  Step 4 - Check Structures",
    "section": "8.2 Specific steps",
    "text": "8.2 Specific steps\n\n8.2.1 Check if there are blank rows on camera trap sheet\nIt is important to check if there are blank rows to avoid the system to find errors where there is no data.\n\n\nCode\nct |&gt;\n  purrr::keep(~ nrow(.x) &gt; 0) |&gt; \n  head(2)\n\n\n$Alberto_Gonzalez\n# A tibble: 8 × 1\n  Structure_id\n  &lt;chr&gt;       \n1 PSF1        \n2 PSF3        \n3 PSF5        \n4 PSF7        \n5 PSF9        \n6 PSF11       \n7 PSF13       \n8 PSF15       \n\n$Ana_Delciellos\n# A tibble: 25 × 1\n   Structure_id\n   &lt;chr&gt;       \n 1 PNSB01      \n 2 PNSB01      \n 3 PNSB01      \n 4 PNSB01      \n 5 PNSB01      \n 6 PNSB02      \n 7 PNSB02      \n 8 PNSB02      \n 9 PNSB03      \n10 PNSB03      \n# ℹ 15 more rows\n\n\n\n\n8.2.2 Check duplicated names between underpasses and overpasses\nWe wouldn’t be able to perform a thorough validation if there are duplicated Structure_id between underpasses and overpasses. In that sense, we created two lists called under and over. We kept on the respective lists solely the datasets that comprise either of these types of structures.\nFollowing this step we load all the underpasses spreadsheets from the files.\n\n\nCode\nunder &lt;- read_sheet(path = \"Excel\",\n                    sheet = \"Underpasses\",\n                    na = c(\"\", \"na\", \"NA\")) |&gt;\n  purrr::map(~ .x |&gt;\n               dplyr::mutate(\n                 Structure_id = as.character(stringr::str_to_upper(Structure_id)),\n                 position = \"under\",\n                 .keep = \"none\")) |&gt;\n  purrr::keep(~ all(nrow(.x) &gt; 0))\n\nover &lt;- read_sheet(path = \"Excel\",\n                   sheet = \"Overpasses\",\n                   na = c(\"\", \"na\", \"NA\")) |&gt;\n  purrr::map(~ .x |&gt;\n               dplyr::mutate(\n                 Structure_id = as.character(stringr::str_to_upper(Structure_id)),\n                 position = \"over\",\n                 .keep = \"none\")) |&gt;\n  purrr::keep(~ nrow(.x) &gt; 0)\n\nhead(under[1])\n\n\n$Alberto_Gonzalez\n# A tibble: 8 × 2\n  Structure_id position\n  &lt;chr&gt;        &lt;chr&gt;   \n1 PSF1         under   \n2 PSF3         under   \n3 PSF5         under   \n4 PSF7         under   \n5 PSF9         under   \n6 PSF11        under   \n7 PSF13        under   \n8 PSF15        under   \n\n\nCode\nhead(over[1])\n\n\n$Benoit_vincent\n# A tibble: 7 × 2\n  Structure_id position\n  &lt;chr&gt;        &lt;chr&gt;   \n1 CE2          over    \n2 CE3          over    \n3 CE4          over    \n4 CE5          over    \n5 CE6          over    \n6 CE7          over    \n7 CE9          over    \n\n\nThe next step is to merge underpasses and overpasses Structure_id from each dataset into a single dataframe.\n\n\nCode\n# Binding under and over in one only list\nunder_over &lt;- list()\n\nfor (i in names(ct)) {\n  exists_in_under &lt;- i %in% names(under)\n  exists_in_over &lt;- i %in% names(over)\n\n  if (exists_in_under & exists_in_over) {\n    under_over[[i]] &lt;- dplyr::bind_rows(under[[i]], over[[i]])\n  }\n  else if (exists_in_under & exists_in_over == FALSE) {\n    under_over[[i]] &lt;- under[[i]]\n  }\n  else {\n    under_over[[i]] &lt;- over[[i]]\n  }\n}\n\nhead(under_over[1])\n\n\n$Alberto_Gonzalez\n# A tibble: 8 × 2\n  Structure_id position\n  &lt;chr&gt;        &lt;chr&gt;   \n1 PSF1         under   \n2 PSF3         under   \n3 PSF5         under   \n4 PSF7         under   \n5 PSF9         under   \n6 PSF11        under   \n7 PSF13        under   \n8 PSF15        under   \n\n\nNow we can check if there are duplicated names for Structure_id. This checks if there are duplicates on overpasses, underpasses and the merge of underpasses and overpasses.\n\n\nCode\nunder_over |&gt;\n  dplyr::bind_rows(.id = \"Dataset\") |&gt;\n  dplyr::count(Dataset, Structure_id, sort = TRUE) |&gt;\n  dplyr::filter(n &gt; 1)\n\n\n# A tibble: 2 × 3\n  Dataset    Structure_id     n\n  &lt;chr&gt;      &lt;chr&gt;        &lt;int&gt;\n1 EricaSaito OAC24            2\n2 EricaSaito OAC89            2\n\n\n\n\n8.2.3 Check if the structures in Camera Trap sheet are in either Underpasses and Overpasses sheet and vice-versa\n\n8.2.3.1 Camera trap x Crossing structures\nInitially, we got from every dataset, the Structure_id from their camera trap spreadsheet and the same field from their underpasses and overpasses spreadsheet. We compared the strings from camera traps and underpasses and overpasses. We expect that for every string on Structure_id camera trap sheet to be included on either underpasses or overpasses sheet.\n\n\nCode\nct_diff_under_over &lt;- purrr::map(names(ct), function(x){\n\n  a &lt;- ct[[x]]\n  uo &lt;- under_over[[x]]\n\n  base::setdiff(a$Structure_id, uo$Structure_id) |&gt;\n    tibble::enframe(name = \"Erro\", value = \"Structure_id\") |&gt;\n    dplyr::mutate(status = \"no_under_nor_over\",\n           position = \"in_ct\")\n}) |&gt;\n  purrr::set_names(names(ct)) |&gt;\n  purrr::keep(~ nrow(.x) &gt; 0) |&gt; # discard datasets without errors\n  dplyr::bind_rows(.id = \"Dataset\")\n\nct_diff_under_over |&gt;\n  print(n = Inf)\n\n\n# A tibble: 61 × 5\n   Dataset                    Erro Structure_id             status      position\n   &lt;chr&gt;                     &lt;int&gt; &lt;chr&gt;                    &lt;chr&gt;       &lt;chr&gt;   \n 1 Arteris_Litoral_Sul_IBAMA     1 ALS-PI-101-SC-054+281    no_under_n… in_ct   \n 2 EricaSaito                    1 KM 437                   no_under_n… in_ct   \n 3 EricaSaito                    2 AR08                     no_under_n… in_ct   \n 4 EricaSaito                    3 AR10                     no_under_n… in_ct   \n 5 EricaSaito                    4 KM 158                   no_under_n… in_ct   \n 6 EricaSaito                    5 KM 192                   no_under_n… in_ct   \n 7 EricaSaito                    6 KM 248                   no_under_n… in_ct   \n 8 EricaSaito                    7 KM 636,7                 no_under_n… in_ct   \n 9 EricaSaito                    8 KM 701                   no_under_n… in_ct   \n10 EricaSaito                    9 KM 770                   no_under_n… in_ct   \n11 EricaSaito                   10 KM 98,3                  no_under_n… in_ct   \n12 EricaSaito                   11 ANTES DO CANTEIRO        no_under_n… in_ct   \n13 EricaSaito                   12 AR100                    no_under_n… in_ct   \n14 EricaSaito                   13 AR14F                    no_under_n… in_ct   \n15 EricaSaito                   14 AR15/IGAPÓ               no_under_n… in_ct   \n16 EricaSaito                   15 AR27                     no_under_n… in_ct   \n17 EricaSaito                   16 AR58                     no_under_n… in_ct   \n18 EricaSaito                   17 AR59                     no_under_n… in_ct   \n19 EricaSaito                   18 AR60                     no_under_n… in_ct   \n20 EricaSaito                   19 AR61                     no_under_n… in_ct   \n21 EricaSaito                   20 AR89                     no_under_n… in_ct   \n22 EricaSaito                   21 AR94F                    no_under_n… in_ct   \n23 EricaSaito                   22 ÁREA VERDE DIREITA       no_under_n… in_ct   \n24 EricaSaito                   23 ÁREA VERDE/ ESQUERDA     no_under_n… in_ct   \n25 EricaSaito                   24 ÁREA VERDE/OAC36 (PERTO) no_under_n… in_ct   \n26 EricaSaito                   25 CAIPIRÃO                 no_under_n… in_ct   \n27 EricaSaito                   26 ENTRE OAC139 OAE PILÃO   no_under_n… in_ct   \n28 EricaSaito                   27 FRAGMENTO                no_under_n… in_ct   \n29 EricaSaito                   28 FRAGMENTO KM 153         no_under_n… in_ct   \n30 EricaSaito                   29 FRAGMENTO KM 91          no_under_n… in_ct   \n31 EricaSaito                   30 FRAGMENTO KM266          no_under_n… in_ct   \n32 EricaSaito                   31 FRAGMENTO LADO PRAD LD   no_under_n… in_ct   \n33 EricaSaito                   32 KM104                    no_under_n… in_ct   \n34 EricaSaito                   33 KM128                    no_under_n… in_ct   \n35 EricaSaito                   34 KM152                    no_under_n… in_ct   \n36 EricaSaito                   35 KM191                    no_under_n… in_ct   \n37 EricaSaito                   36 KM214                    no_under_n… in_ct   \n38 EricaSaito                   37 KM223,3                  no_under_n… in_ct   \n39 EricaSaito                   38 KM224                    no_under_n… in_ct   \n40 EricaSaito                   39 KM296,7                  no_under_n… in_ct   \n41 EricaSaito                   40 KM317                    no_under_n… in_ct   \n42 EricaSaito                   41 KM349                    no_under_n… in_ct   \n43 EricaSaito                   42 KM455                    no_under_n… in_ct   \n44 EricaSaito                   43 KM501                    no_under_n… in_ct   \n45 EricaSaito                   44 KM575                    no_under_n… in_ct   \n46 EricaSaito                   45 KM681,4                  no_under_n… in_ct   \n47 EricaSaito                   46 KM711                    no_under_n… in_ct   \n48 EricaSaito                   47 KM797                    no_under_n… in_ct   \n49 EricaSaito                   48 OAC NOVO (CAM006)        no_under_n… in_ct   \n50 EricaSaito                   49 OAC110/KM91              no_under_n… in_ct   \n51 EricaSaito                   50 OAC14                    no_under_n… in_ct   \n52 EricaSaito                   51 OAC18                    no_under_n… in_ct   \n53 EricaSaito                   52 OAC251                   no_under_n… in_ct   \n54 EricaSaito                   53 OAC74/AR40               no_under_n… in_ct   \n55 EricaSaito                   54 PONTE PIAUÍ KM379        no_under_n… in_ct   \n56 EricaSaito                   55 PRÓX. PONTE DOS MILAGRES no_under_n… in_ct   \n57 EricaSaito                   56 PRÓXIMO À OAC            no_under_n… in_ct   \n58 EricaSaito                   57 PROXIMO A OAC 36A        no_under_n… in_ct   \n59 EricaSaito                   58 RASTRO/DIREITA           no_under_n… in_ct   \n60 EricaSaito                   59 OAC089                   no_under_n… in_ct   \n61 EricaSaito                   60 OAC63                    no_under_n… in_ct   \n\n\n\n\n8.2.3.2 Crossing structures x Camera trap\nWe apply here the same strategy as above, but in the opposite direction.\n\n\nCode\nunder_over_diff_ct &lt;- purrr::map(names(ct), function(x){\n\n  a &lt;- ct[[x]]\n  uo &lt;- under_over[[x]]\n\n  base::setdiff(uo$Structure_id, a$Structure_id) |&gt;\n    tibble::enframe(name = \"Erro\", value = \"Structure_id\") |&gt;\n    dplyr::mutate(status = \"not_in_ct\") |&gt;\n    dplyr::left_join(under_over[[x]], by = \"Structure_id\")\n}) |&gt;\n  purrr::set_names(names(ct)) |&gt;\n  purrr::keep(~ nrow(.x) &gt; 0) |&gt;\n  dplyr::bind_rows(.id = \"Dataset\")\n\ndplyr::bind_rows(ct_diff_under_over, under_over_diff_ct) |&gt;\n  dplyr::arrange(Dataset) |&gt;\n  print(n = Inf)\n\n\n# A tibble: 70 × 5\n   Dataset                    Erro Structure_id               status    position\n   &lt;chr&gt;                     &lt;int&gt; &lt;chr&gt;                      &lt;chr&gt;     &lt;chr&gt;   \n 1 Arteris_Litoral_Sul_IBAMA     1 ALS-PI-101-SC-054+281      no_under… in_ct   \n 2 Arteris_Litoral_Sul_IBAMA     1 ALS-PI-101-SC-054+282      not_in_ct under   \n 3 EricaSaito                    1 KM 437                     no_under… in_ct   \n 4 EricaSaito                    2 AR08                       no_under… in_ct   \n 5 EricaSaito                    3 AR10                       no_under… in_ct   \n 6 EricaSaito                    4 KM 158                     no_under… in_ct   \n 7 EricaSaito                    5 KM 192                     no_under… in_ct   \n 8 EricaSaito                    6 KM 248                     no_under… in_ct   \n 9 EricaSaito                    7 KM 636,7                   no_under… in_ct   \n10 EricaSaito                    8 KM 701                     no_under… in_ct   \n11 EricaSaito                    9 KM 770                     no_under… in_ct   \n12 EricaSaito                   10 KM 98,3                    no_under… in_ct   \n13 EricaSaito                   11 ANTES DO CANTEIRO          no_under… in_ct   \n14 EricaSaito                   12 AR100                      no_under… in_ct   \n15 EricaSaito                   13 AR14F                      no_under… in_ct   \n16 EricaSaito                   14 AR15/IGAPÓ                 no_under… in_ct   \n17 EricaSaito                   15 AR27                       no_under… in_ct   \n18 EricaSaito                   16 AR58                       no_under… in_ct   \n19 EricaSaito                   17 AR59                       no_under… in_ct   \n20 EricaSaito                   18 AR60                       no_under… in_ct   \n21 EricaSaito                   19 AR61                       no_under… in_ct   \n22 EricaSaito                   20 AR89                       no_under… in_ct   \n23 EricaSaito                   21 AR94F                      no_under… in_ct   \n24 EricaSaito                   22 ÁREA VERDE DIREITA         no_under… in_ct   \n25 EricaSaito                   23 ÁREA VERDE/ ESQUERDA       no_under… in_ct   \n26 EricaSaito                   24 ÁREA VERDE/OAC36 (PERTO)   no_under… in_ct   \n27 EricaSaito                   25 CAIPIRÃO                   no_under… in_ct   \n28 EricaSaito                   26 ENTRE OAC139 OAE PILÃO     no_under… in_ct   \n29 EricaSaito                   27 FRAGMENTO                  no_under… in_ct   \n30 EricaSaito                   28 FRAGMENTO KM 153           no_under… in_ct   \n31 EricaSaito                   29 FRAGMENTO KM 91            no_under… in_ct   \n32 EricaSaito                   30 FRAGMENTO KM266            no_under… in_ct   \n33 EricaSaito                   31 FRAGMENTO LADO PRAD LD     no_under… in_ct   \n34 EricaSaito                   32 KM104                      no_under… in_ct   \n35 EricaSaito                   33 KM128                      no_under… in_ct   \n36 EricaSaito                   34 KM152                      no_under… in_ct   \n37 EricaSaito                   35 KM191                      no_under… in_ct   \n38 EricaSaito                   36 KM214                      no_under… in_ct   \n39 EricaSaito                   37 KM223,3                    no_under… in_ct   \n40 EricaSaito                   38 KM224                      no_under… in_ct   \n41 EricaSaito                   39 KM296,7                    no_under… in_ct   \n42 EricaSaito                   40 KM317                      no_under… in_ct   \n43 EricaSaito                   41 KM349                      no_under… in_ct   \n44 EricaSaito                   42 KM455                      no_under… in_ct   \n45 EricaSaito                   43 KM501                      no_under… in_ct   \n46 EricaSaito                   44 KM575                      no_under… in_ct   \n47 EricaSaito                   45 KM681,4                    no_under… in_ct   \n48 EricaSaito                   46 KM711                      no_under… in_ct   \n49 EricaSaito                   47 KM797                      no_under… in_ct   \n50 EricaSaito                   48 OAC NOVO (CAM006)          no_under… in_ct   \n51 EricaSaito                   49 OAC110/KM91                no_under… in_ct   \n52 EricaSaito                   50 OAC14                      no_under… in_ct   \n53 EricaSaito                   51 OAC18                      no_under… in_ct   \n54 EricaSaito                   52 OAC251                     no_under… in_ct   \n55 EricaSaito                   53 OAC74/AR40                 no_under… in_ct   \n56 EricaSaito                   54 PONTE PIAUÍ KM379          no_under… in_ct   \n57 EricaSaito                   55 PRÓX. PONTE DOS MILAGRES   no_under… in_ct   \n58 EricaSaito                   56 PRÓXIMO À OAC              no_under… in_ct   \n59 EricaSaito                   57 PROXIMO A OAC 36A          no_under… in_ct   \n60 EricaSaito                   58 RASTRO/DIREITA             no_under… in_ct   \n61 EricaSaito                   59 OAC089                     no_under… in_ct   \n62 EricaSaito                   60 OAC63                      no_under… in_ct   \n63 EricaSaito                    1 OAC36A                     not_in_ct under   \n64 EricaSaito                    2 OACNOVO                    not_in_ct under   \n65 EricaSaito                    3 PRÓXIMO À OAC/ ESTACA 6555 not_in_ct under   \n66 EricaSaito                    4 OAC074                     not_in_ct under   \n67 Sidnei                        1 BCS1                       not_in_ct under   \n68 Sidnei                        2 BCS2                       not_in_ct under   \n69 Sidnei                        3 PAEREA                     not_in_ct over    \n70 Tatiane_Marina                1 SUB_4A                     not_in_ct under   \n\n\n\n\n\n8.2.4 Check if fences are present on underpasses\nFirstly we read the Fencing spreadsheet for every dataset, filtering for only those who have any row filled.\n\n\nCode\nfences &lt;- read_sheet(path = \"Excel\",\n                     sheet = \"Fencing\",\n                     na = \"NA\") |&gt;\n  purrr::map(~ .x |&gt;\n               dplyr::mutate(\n                 Structure_id = as.character(stringr::str_to_upper(Structure_id)),\n                 position = \"under\",\n                 .keep = \"none\")) |&gt;\n  purrr::keep(~ nrow(.x) &gt; 0)\n\n\nWe then check if all the Structure_id listed on the Fencing spreadsheet are comprised on the Structure_id on the Underpasses spreadsheet.\n\n\nCode\nfences_diff_under &lt;- purrr::map(names(fences), function(x){\n\n  a &lt;- fences[[x]]\n  u &lt;- under[[x]]\n\n  base::setdiff(a$Structure_id, u$Structure_id) |&gt;\n    tibble::enframe(name = \"Erro\", value = \"Structure_id\") |&gt;\n    dplyr::mutate(status = \"no_under\",\n           position = \"in_fences\")\n}) |&gt;\n  purrr::set_names(names(fences)) |&gt;\n  purrr::keep(~ nrow(.x) &gt; 0) |&gt;\n  dplyr::bind_rows(.id = \"Dataset\")\n\nfences_diff_under |&gt;\n  print(n = Inf)\n\n\n# A tibble: 4 × 5\n  Dataset                    Erro Structure_id          status   position \n  &lt;chr&gt;                     &lt;int&gt; &lt;chr&gt;                 &lt;chr&gt;    &lt;chr&gt;    \n1 Arteris_Litoral_Sul_IBAMA     1 ALS-PI-101-SC-054+281 no_under in_fences\n2 Thomas                        1 PFB06                 no_under in_fences\n3 Thomas                        2 PFB07                 no_under in_fences\n4 Thomas                        3 PFB08                 no_under in_fences\n\n\nWe then proceed on the opposite direction, checking if there are Structure_id on the Underpasses spreadsheet not encompassed on Fencing. Obviously, there are passages that could not have been fenced, however, we play it conservatively to check with the authors if this is the case or if they have forgotten to fill the Fencing spreadsheet correctly.\n\n\nCode\nunder_fences_diff &lt;- purrr::map(names(fences), function(x){\n\n  a &lt;- fences[[x]]\n  u &lt;- under[[x]]\n\n  base::setdiff(u$Structure_id, a$Structure_id) |&gt;\n    tibble::enframe(name = \"Erro\", value = \"Structure_id\") |&gt;\n    dplyr::mutate(status = \"no_fences\",\n           position = \"in_under\")\n}) |&gt;\n  purrr::set_names(names(fences)) |&gt;\n  purrr::keep(~ nrow(.x) &gt; 0) |&gt;\n  dplyr::bind_rows(.id = \"Dataset\")\n\nunder_fences_diff |&gt;\n  print(n = Inf)\n\n\n# A tibble: 8 × 5\n  Dataset                    Erro Structure_id          status    position\n  &lt;chr&gt;                     &lt;int&gt; &lt;chr&gt;                 &lt;chr&gt;     &lt;chr&gt;   \n1 Arteris_Litoral_Sul_IBAMA     1 ALS-PI-101-SC-054+282 no_fences in_under\n2 Arteris_Litoral_Sul_IBAMA     2 ALS-PI-101-SC-054+889 no_fences in_under\n3 Arteris_Litoral_Sul_IBAMA     3 ALS-PI-101-SC-235+315 no_fences in_under\n4 Tatiane_Marina                1 SUB_0A                no_fences in_under\n5 Tatiane_Marina                2 SUB_0B                no_fences in_under\n6 Tatiane_Marina                3 SUB_4A                no_fences in_under\n7 Tatiane_Marina                4 SUB_5A                no_fences in_under\n8 Tatiane_Marina                5 SUB_5B                no_fences in_under",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Step 4 - Check Structures</span>"
    ]
  },
  {
    "objectID": "Quarto/05_CHECK_ID_CAMERA.html",
    "href": "Quarto/05_CHECK_ID_CAMERA.html",
    "title": "7  Step 5 - Check ID on Camera",
    "section": "",
    "text": "8 Problem Description\nThis document explains the process of verifying camera IDs between two datasets: the camera trap setup data and the species records data. The goal is to identify any mismatches or inconsistencies in camera IDs between these datasets.",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Step 5 - Check ID on Camera</span>"
    ]
  },
  {
    "objectID": "Quarto/05_CHECK_ID_CAMERA.html#common-steps",
    "href": "Quarto/05_CHECK_ID_CAMERA.html#common-steps",
    "title": "7  Step 5 - Check ID on Camera",
    "section": "9.1 Common steps",
    "text": "9.1 Common steps\nTo solve this issue, we follow some of the first basic steps from previous checks, as using our customized read_sheet function that provides the full paths of all .xlsx files available in order to read the species sheet from all files.\n\n\nCode\nsource(\"R/FUNCTIONS.R\")",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Step 5 - Check ID on Camera</span>"
    ]
  },
  {
    "objectID": "Quarto/05_CHECK_ID_CAMERA.html#data-loading",
    "href": "Quarto/05_CHECK_ID_CAMERA.html#data-loading",
    "title": "7  Step 5 - Check ID on Camera",
    "section": "9.2 Data Loading",
    "text": "9.2 Data Loading\nWe load two datasets from the spreadsheet: 1. Camera trap setup data (ct) 2. Species records data (rec)\n\n\nCode\n# Read camera trap setup data\nct &lt;- read_sheet(sheet = \"Camera_trap\")\n\n# Read species records data\nrec &lt;- read_sheet(sheet = \"Species_records_camera\")",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Step 5 - Check ID on Camera</span>"
    ]
  },
  {
    "objectID": "Quarto/05_CHECK_ID_CAMERA.html#verification-process",
    "href": "Quarto/05_CHECK_ID_CAMERA.html#verification-process",
    "title": "7  Step 5 - Check ID on Camera",
    "section": "9.3 Verification Process",
    "text": "9.3 Verification Process\nThe verification process consists of two main checks:\n\n9.3.1 Records to Camera Trap Check\nThis check identifies any camera IDs in the species records that don’t exist in the camera trap data:\n\n\nCode\nrecord_to_ct &lt;- purrr::map2(ct, rec, function(c, r) {\n  base::setdiff(r$Camera_id, c$Camera_id) |&gt;\n    tibble::enframe(name = \"Error\", value = \"Camera_id\") |&gt;\n    dplyr::mutate(note = \"Record without camera on sheet\")\n}) |&gt;\n  purrr::discard(~ nrow(.x) == 0) |&gt;\n  dplyr::bind_rows(.id = \"Dataset\")\n\nhead(record_to_ct)\n\n\n# A tibble: 6 × 4\n  Dataset        Error Camera_id           note                          \n  &lt;chr&gt;          &lt;int&gt; &lt;chr&gt;               &lt;chr&gt;                         \n1 Carlos_Scarlat     1 Trap6_Bueiro84N     Record without camera on sheet\n2 Carlos_Scarlat     2 Trap6_Bueiro40N     Record without camera on sheet\n3 NERF               1 &lt;NA&gt;                Record without camera on sheet\n4 Paludosa           1 PF03_CANINANA_E1_C2 Record without camera on sheet\n5 Paludosa           2 PF03_CANINANA_E1_C3 Record without camera on sheet\n6 Paludosa           3 PF03_CANINANA_E1_C4 Record without camera on sheet\n\n\n\n\n9.3.2 Camera Trap to Records Check\nThis check identifies any camera IDs in the camera trap data that don’t have corresponding records:\n\n\nCode\nct_to_record &lt;- purrr::map2(ct, rec, function(c, r) {\n  base::setdiff(c$Camera_id, r$Camera_id) |&gt;\n    tibble::enframe(name = \"Error\", value = \"Camera_id\") |&gt;\n    dplyr::mutate(note = \"Camera without record on sheet\")\n}) |&gt;\n  purrr::discard(~ nrow(.x) == 0) |&gt;\n  dplyr::bind_rows(.id = \"Dataset\")\n\nhead(ct_to_record)\n\n\n# A tibble: 6 × 4\n  Dataset                   Error Camera_id  note                          \n  &lt;chr&gt;                     &lt;int&gt; &lt;chr&gt;      &lt;chr&gt;                         \n1 Ana_Delciellos                1 PNSB_cam1a Camera without record on sheet\n2 Ana_Delciellos                2 PNSB_cam2c Camera without record on sheet\n3 Ana_Delciellos                3 PNSB_cam4b Camera without record on sheet\n4 Ana_Delciellos                4 PNSB_cam5a Camera without record on sheet\n5 Ana_Delciellos                5 PNSB_cam6a Camera without record on sheet\n6 Arteris_Litoral_Sul_IBAMA     1 CAM-0008   Camera without record on sheet",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Step 5 - Check ID on Camera</span>"
    ]
  },
  {
    "objectID": "Quarto/05_CHECK_ID_CAMERA.html#output-generation",
    "href": "Quarto/05_CHECK_ID_CAMERA.html#output-generation",
    "title": "7  Step 5 - Check ID on Camera",
    "section": "9.4 Output Generation",
    "text": "9.4 Output Generation\nFinally, we combine both checks and save the results to an Excel file:\n\n\nCode\nrecord_to_ct |&gt;\n  dplyr::bind_rows(ct_to_record) |&gt;\n  openxlsx::write.xlsx(\"Output/check_id_errors.xlsx\", asTable = TRUE)",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Step 5 - Check ID on Camera</span>"
    ]
  },
  {
    "objectID": "Quarto/05_CHECK_ID_CAMERA.html#results-interpretation",
    "href": "Quarto/05_CHECK_ID_CAMERA.html#results-interpretation",
    "title": "7  Step 5 - Check ID on Camera",
    "section": "9.5 Results Interpretation",
    "text": "9.5 Results Interpretation\nThe output file check_id_errors.xlsx contains two types of errors:\n\nCamera IDs that appear in species records but not in the camera trap data\nCamera IDs that appear in the camera trap data but have no corresponding species records\n\nThis helps identify potential data entry errors or missing information in either dataset.",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Step 5 - Check ID on Camera</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Quality Checks",
    "section": "",
    "text": "0.1 Welcome\nThis book documents the data quality checks performed on the camera trap data. Each chapter describes a specific check and its implementation.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Datapaper WildCrossData Latin America</span>"
    ]
  },
  {
    "objectID": "index.html#chapters",
    "href": "index.html#chapters",
    "title": "Data Quality Checks",
    "section": "0.2 Chapters",
    "text": "0.2 Chapters\n\nColumn Consistency - Checks for consistency in column types across spreadsheets.\nBlank Cells - Identifies blank cells and sheets in the data.\nSpecies Validity - Validates species names using the Global Names Verifier API.\nStructure Checks - Verifies consistency between camera trap and structure data\nCamera ID Verification - Ensures camera IDs are properly linked across datasets.\nCamera Date Checks - Checks several possibilities for anomalous dates.\nCamera ID Duplicated on Structure - Tests if there is a duplicated camera IDs for a given structure.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Datapaper WildCrossData Latin America</span>"
    ]
  },
  {
    "objectID": "index.html#about",
    "href": "index.html#about",
    "title": "Data Quality Checks",
    "section": "0.3 About",
    "text": "0.3 About\nThis book is part of the data quality assurance process for the camera trap dataset. Each check is implemented in R and documented using Quarto.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Datapaper WildCrossData Latin America</span>"
    ]
  },
  {
    "objectID": "Quarto/06_CHECK_DATE.html",
    "href": "Quarto/06_CHECK_DATE.html",
    "title": "8  Step 7 - Check Date Consistency",
    "section": "",
    "text": "9 Problem Description\nThis document describes the process of checking date and time consistency in the camera trap dataset. The goal is to identify records with inconsistent sampling periods, future dates, or species records outside the sampling interval.",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Step 7 - Check Date Consistency</span>"
    ]
  },
  {
    "objectID": "Quarto/06_CHECK_DATE.html#common-steps",
    "href": "Quarto/06_CHECK_DATE.html#common-steps",
    "title": "8  Step 7 - Check Date Consistency",
    "section": "10.1 Common Steps",
    "text": "10.1 Common Steps\nWe start by loading the required functions and packages.\n\n\nCode\nlibrary(hms)\nlibrary(tidyverse)\nsource(\"R/FUNCTIONS.R\")\n\n\nWe load the camera trap setup data for further checks.\n\n\nCode\nct &lt;- read_sheet(sheet = \"Camera_trap\", na = c(\"NA\", \"na\"))",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Step 7 - Check Date Consistency</span>"
    ]
  },
  {
    "objectID": "Quarto/06_CHECK_DATE.html#load-camera-trap-data",
    "href": "Quarto/06_CHECK_DATE.html#load-camera-trap-data",
    "title": "8  Step 7 - Check Date Consistency",
    "section": "10.2 Load Camera Trap Data",
    "text": "10.2 Load Camera Trap Data\nWe load the camera trap setup data for further checks.\n\n\nCode\nct &lt;- read_sheet(sheet = \"Camera_trap\", na = c(\"NA\", \"na\"))",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Step 7 - Check Date Consistency</span>"
    ]
  },
  {
    "objectID": "Quarto/06_CHECK_DATE.html#check-for-short-sampling-durations",
    "href": "Quarto/06_CHECK_DATE.html#check-for-short-sampling-durations",
    "title": "8  Step 7 - Check Date Consistency",
    "section": "10.2 Check for Short Sampling Durations",
    "text": "10.2 Check for Short Sampling Durations\nWe identify camera deployments with a sampling duration of less than 24 hours (86,400 seconds).\n\n\nCode\ncheck_date_before &lt;- map(.x = ct, function(dataset) {\n    dataset |&gt;\n        dttm_update(date_col = \"Start_date\", time_col = \"Start_time\") |&gt;\n        dttm_update(date_col = \"End_date\", time_col = \"End_time\") |&gt;\n        select(-ends_with(\"_time\")) |&gt;\n        mutate(\n            duration = as.duration(Start_date %--% End_date)\n        ) |&gt;\n        filter(duration &lt; 86400)\n}) |&gt;\n    bind_rows(.id = \"dataset\") |&gt;\n    select(dataset, Camera_id, Start_date:duration)\n\ncheck_date_before\n\n\n# A tibble: 28 × 30\n   dataset      Camera_id Start_date          End_date            Camera_problem\n   &lt;chr&gt;        &lt;chr&gt;     &lt;dttm&gt;              &lt;dttm&gt;              &lt;chr&gt;         \n 1 EcoRioMinas… Cam024S   2024-01-13 02:06:00 2024-01-13 02:06:00 Sim           \n 2 Guillermo_G… cam5      2013-03-28 10:19:00 2013-03-29 00:31:00 Sí            \n 3 Marina_souza CB04      2019-11-25 13:02:00 2019-08-28 17:45:12 Não           \n 4 Marina_souza CB03      2019-11-25 11:42:25 2019-08-28 08:41:00 Não           \n 5 Marina_souza CB01      2019-11-26 17:15:25 2019-08-28 17:23:00 Não           \n 6 Marina_souza CB05      2019-11-26 17:31:00 2019-08-28 17:49:00 Não           \n 7 Marina_souza CB01      2021-08-31 17:37:00 2021-08-06 07:20:00 Não           \n 8 Marina_souza CB06      2021-09-01 12:36:00 2021-08-05 16:15:00 Não           \n 9 Marina_souza CB04      2021-09-01 12:46:00 2021-08-05 16:35:00 Não           \n10 Marina_souza CB03      2021-09-01 13:52:00 2021-08-06 07:28:00 Não           \n# ℹ 18 more rows\n# ℹ 25 more variables: Problem1_from &lt;dttm&gt;, Problem1_to &lt;dttm&gt;,\n#   Problem2_from &lt;dttm&gt;, Problem2_to &lt;dttm&gt;, Problem3_from &lt;dttm&gt;,\n#   Problem3_to &lt;dttm&gt;, Problem4_from &lt;dttm&gt;, Problem4_to &lt;dttm&gt;,\n#   Problem5_from &lt;dttm&gt;, Problem5_to &lt;dttm&gt;, Problem6_from &lt;dttm&gt;,\n#   Problem6_to &lt;dttm&gt;, Problem7_from &lt;dttm&gt;, Problem7_to &lt;dttm&gt;,\n#   Problem8_from &lt;dttm&gt;, Problem8_to &lt;dttm&gt;, Problem9_from &lt;dttm&gt;, …",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Step 7 - Check Date Consistency</span>"
    ]
  },
  {
    "objectID": "Quarto/06_CHECK_DATE.html#check-for-excessively-long-sampling-durations",
    "href": "Quarto/06_CHECK_DATE.html#check-for-excessively-long-sampling-durations",
    "title": "8  Step 7 - Check Date Consistency",
    "section": "10.3 Check for Excessively Long Sampling Durations",
    "text": "10.3 Check for Excessively Long Sampling Durations\nWe identify deployments with a sampling duration longer than 3 months (7,776,000 seconds).\n\n\nCode\ncheck_date_after &lt;- map(.x = ct, function(dataset) {\n    dataset |&gt;\n        dttm_update(date_col = \"Start_date\", time_col = \"Start_time\") |&gt;\n        dttm_update(date_col = \"End_date\", time_col = \"End_time\") |&gt;\n        select(-ends_with(\"_time\")) |&gt;\n        mutate(\n            duration = as.duration(Start_date %--% End_date)\n        ) |&gt;\n        filter(duration &gt; 7776000)\n}) |&gt;\n    bind_rows(.id = \"dataset\") |&gt;\n    select(dataset, Camera_id, Start_date:duration)\n\ncheck_date_after\n\n\n# A tibble: 102 × 30\n   dataset      Camera_id Start_date          End_date            Camera_problem\n   &lt;chr&gt;        &lt;chr&gt;     &lt;dttm&gt;              &lt;dttm&gt;              &lt;chr&gt;         \n 1 Alberto_Gon… CAM63309  2017-07-14 10:25:00 2018-10-18 15:05:00 No            \n 2 Alberto_Gon… CAM63364  2017-07-14 11:05:00 2018-10-13 23:59:00 No            \n 3 Alberto_Gon… CAM63419  2017-07-14 11:40:00 2018-10-18 10:44:00 No            \n 4 Alberto_Gon… CAM63551  2017-07-14 12:27:00 2018-10-18 16:02:00 No            \n 5 Alberto_Gon… CAM63615  2017-07-14 13:18:00 2018-09-14 14:30:00 No            \n 6 Alberto_Gon… CAM63624  2017-07-14 14:02:00 2018-10-18 14:54:00 No            \n 7 Alberto_Gon… CAM63643  2017-07-14 14:55:00 2018-10-18 13:37:00 No            \n 8 Alberto_Gon… CAM63650  2017-07-14 15:45:00 2018-10-18 13:01:00 No            \n 9 Carlos_Scar… Trap01_P… 2017-03-01 10:00:00 2018-02-28 10:30:00 Não           \n10 Carlos_Scar… Trap3_Bu… 2017-05-01 10:00:00 2018-02-28 11:00:00 Sim           \n# ℹ 92 more rows\n# ℹ 25 more variables: Problem1_from &lt;dttm&gt;, Problem1_to &lt;dttm&gt;,\n#   Problem2_from &lt;dttm&gt;, Problem2_to &lt;dttm&gt;, Problem3_from &lt;dttm&gt;,\n#   Problem3_to &lt;dttm&gt;, Problem4_from &lt;dttm&gt;, Problem4_to &lt;dttm&gt;,\n#   Problem5_from &lt;dttm&gt;, Problem5_to &lt;dttm&gt;, Problem6_from &lt;dttm&gt;,\n#   Problem6_to &lt;dttm&gt;, Problem7_from &lt;dttm&gt;, Problem7_to &lt;dttm&gt;,\n#   Problem8_from &lt;dttm&gt;, Problem8_to &lt;dttm&gt;, Problem9_from &lt;dttm&gt;, …",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Step 7 - Check Date Consistency</span>"
    ]
  },
  {
    "objectID": "Quarto/06_CHECK_DATE.html#check-for-future-dates",
    "href": "Quarto/06_CHECK_DATE.html#check-for-future-dates",
    "title": "8  Step 7 - Check Date Consistency",
    "section": "10.4 Check for Future Dates",
    "text": "10.4 Check for Future Dates\nWe flag deployments with start or end dates set in the future. We defined the threshold date as April 30th, 2025.\n\n\nCode\ncheck_date_future &lt;- map(.x = ct, function(dataset) {\n    data_thresh &lt;- \"2025-04-30\"\n    dataset |&gt;\n        mutate(\n            date_start = ymd(as.character(Start_date)),\n            date_end = ymd(as.character(End_date))\n        ) |&gt;\n        filter(if_any(starts_with(\"date_\"), ~ .x &gt; data_thresh))\n}) |&gt;\n    bind_rows(.id = \"dataset\") |&gt;\n    select(dataset, Camera_id, date_start:date_end)\n\ncheck_date_future\n\n\n# A tibble: 0 × 4\n# ℹ 4 variables: dataset &lt;chr&gt;, Camera_id &lt;chr&gt;, date_start &lt;date&gt;,\n#   date_end &lt;date&gt;",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Step 7 - Check Date Consistency</span>"
    ]
  },
  {
    "objectID": "Quarto/06_CHECK_DATE.html#load-species-records",
    "href": "Quarto/06_CHECK_DATE.html#load-species-records",
    "title": "8  Step 7 - Check Date Consistency",
    "section": "10.6 Load Species Records",
    "text": "10.6 Load Species Records\nWe load the species records data for cross-checking with camera trap intervals.\n\n\nCode\nrec &lt;- read_sheet(sheet = \"Species_records_camera\", na = c(\"NA\", \"na\"))\ndatasets &lt;- names(rec)",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Step 7 - Check Date Consistency</span>"
    ]
  },
  {
    "objectID": "Quarto/06_CHECK_DATE.html#check-species-records-within-sampling-interval",
    "href": "Quarto/06_CHECK_DATE.html#check-species-records-within-sampling-interval",
    "title": "8  Step 7 - Check Date Consistency",
    "section": "10.5 Check Species Records Within Sampling Interval",
    "text": "10.5 Check Species Records Within Sampling Interval\nWe load the species records data for cross-checking with camera trap intervals.\n\n\nCode\nrec &lt;- read_sheet(\n  sheet = \"Species_records_camera\", \n  na = c(\"NA\", \"na\")\n  )\n\ndatasets &lt;- names(rec)\n\n\nWe check if each species record falls within the sampling interval of the corresponding camera.\n\n\nCode\nspecies_records_within_ct_date &lt;- list()\nerror_log &lt;- tibble(dataset = character(), error_message = character())\n\nfor (dataset in datasets) {\n    message(str_glue(\"Starting dataset {dataset}\\n\"))\n    tryCatch(\n        {\n            camera &lt;- ct[[dataset]] |&gt;\n                select(Structure_id, Camera_id, Start_date, End_date)\n\n            species_records_within_ct_date[[dataset]] &lt;- rec[[dataset]] |&gt;\n                inner_join(camera, by = c(\"Camera_id\", \"Structure_id\")) |&gt;\n                mutate(\n                    across(ends_with(\"date\"), as_datetime),\n                    row = row_number(),\n                    check = case_when(\n                        Record_date %within% c(Start_date %--% End_date) ~\n                            \"YES\",\n                        TRUE ~ \"NO\"\n                    )\n                ) |&gt;\n                filter(check == \"NO\") |&gt;\n                select(row, Species, Camera_id, ends_with(\"date\"), check)\n            message(str_glue(\"Finalizing dataset {dataset}\\n\"))\n        },\n        error = function(e) {\n            msg &lt;- as.character(e$message)\n            error_log &lt;&lt;- bind_rows(\n                error_log,\n                tibble(dataset = dataset, error_message = msg)\n            )\n            message(str_glue(\"Error in dataset {dataset}: {msg}\\n\"))\n            return(NULL)\n        }\n    )\n}\n\nerror_log\n\n\n# A tibble: 2 × 2\n  dataset        error_message                         \n  &lt;chr&gt;          &lt;chr&gt;                                 \n1 NERF           In argument: `check = case_when(...)`.\n2 Tatiane_Marina In argument: `check = case_when(...)`.\n\n\nWe summarize and print the number of records outside the sampling interval for each dataset.\n\n\nCode\nspecies_records_within_ct_date |&gt;\n    discard(~ nrow(.x) == 0) |&gt;\n    bind_rows(.id = \"dataset\") |&gt;\n    count(dataset, sort = TRUE) |&gt;\n    print(n = Inf)\n\n\n# A tibble: 28 × 2\n   dataset                          n\n   &lt;chr&gt;                        &lt;int&gt;\n 1 Tremie_Peru_Sagari_Gregory    6003\n 2 EGR_data02                    1074\n 3 BR116_392_IBAMA                906\n 4 Sidnei                         304\n 5 Rodolfo_cervantes              178\n 6 Marina_souza                   137\n 7 Soledad                        136\n 8 Benoit_vincent                 110\n 9 Eugenio_Larios                 104\n10 Paludosa                        78\n11 SC290_IBAMA                     73\n12 Tremie_Peru_Pagoreni_Gregory    59\n13 BR153_IBAMA                     52\n14 Guillermo_Gil                   51\n15 Leandro_Macedo                  14\n16 EcoRioMinas_IBAMA                8\n17 Arteris_Litoral_Sul_IBAMA        5\n18 Caue_Monticelli                  3\n19 EGR_data01                       3\n20 ReginaldoCruz                    3\n21 Francisco_Alves                  2\n22 Geisy                            2\n23 Hugo_Coitino                     2\n24 Carolina_Gomez                   1\n25 Eleanor                          1\n26 EricaSaito                       1\n27 PatriciaDias                     1\n28 Paulo_Tomasi                     1\n\n\nWe export the records outside the sampling interval to an Excel file.\n\n\nCode\nspecies_records_within_ct_date |&gt; \n  openxlsx::write.xlsx( \"Output/REGISTROS_SP_FORA_DA_DATA.xlsx\", asTable = TRUE, colWidths = \"auto\" )",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Step 7 - Check Date Consistency</span>"
    ]
  },
  {
    "objectID": "Quarto/06_CHECK_DATE.html#summary-of-records-outside-sampling-interval",
    "href": "Quarto/06_CHECK_DATE.html#summary-of-records-outside-sampling-interval",
    "title": "8  Step 7 - Check Date Consistency",
    "section": "10.8 Summary of Records Outside Sampling Interval",
    "text": "10.8 Summary of Records Outside Sampling Interval\nWe summarize and print the number of records outside the sampling interval for each dataset.\n\n\nCode\nspecies_records_within_ct_date |&gt;\n    discard(~ nrow(.x) == 0) |&gt;\n    bind_rows(.id = \"dataset\") |&gt;\n    count(dataset, sort = TRUE) |&gt;\n    print(n = Inf)\n\n\n# A tibble: 28 × 2\n   dataset                          n\n   &lt;chr&gt;                        &lt;int&gt;\n 1 Tremie_Peru_Sagari_Gregory    6003\n 2 EGR_data02                    1074\n 3 BR116_392_IBAMA                906\n 4 Sidnei                         304\n 5 Rodolfo_cervantes              178\n 6 Marina_souza                   137\n 7 Soledad                        136\n 8 Benoit_vincent                 110\n 9 Eugenio_Larios                 104\n10 Paludosa                        78\n11 SC290_IBAMA                     73\n12 Tremie_Peru_Pagoreni_Gregory    59\n13 BR153_IBAMA                     52\n14 Guillermo_Gil                   51\n15 Leandro_Macedo                  14\n16 EcoRioMinas_IBAMA                8\n17 Arteris_Litoral_Sul_IBAMA        5\n18 Caue_Monticelli                  3\n19 EGR_data01                       3\n20 ReginaldoCruz                    3\n21 Francisco_Alves                  2\n22 Geisy                            2\n23 Hugo_Coitino                     2\n24 Carolina_Gomez                   1\n25 Eleanor                          1\n26 EricaSaito                       1\n27 PatriciaDias                     1\n28 Paulo_Tomasi                     1",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Step 7 - Check Date Consistency</span>"
    ]
  },
  {
    "objectID": "Quarto/06_CHECK_DATE.html#export-results",
    "href": "Quarto/06_CHECK_DATE.html#export-results",
    "title": "8  Step 7 - Check Date Consistency",
    "section": "10.9 Export Results",
    "text": "10.9 Export Results\nWe export the records outside the sampling interval to an Excel file.\n\n\nCode\nspecies_records_within_ct_date |&gt; \n  openxlsx::write.xlsx( \"Output/REGISTROS_SP_FORA_DA_DATA.xlsx\", asTable = TRUE, colWidths = \"auto\" )",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Step 7 - Check Date Consistency</span>"
    ]
  },
  {
    "objectID": "Quarto/07_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html",
    "href": "Quarto/07_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html",
    "title": "9  Step 7 - Check Duplicated Camera on Structure",
    "section": "",
    "text": "10 Problem Description\nThis document describes the process of identifying duplicated camera IDs within the same structure in the camera trap setup data. The goal is to ensure that each camera within a structure is uniquely identified, avoiding overlaps that could compromise data integrity.",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Step 7 - Check Duplicated Camera on Structure</span>"
    ]
  },
  {
    "objectID": "Quarto/07_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#common-steps",
    "href": "Quarto/07_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#common-steps",
    "title": "9  Step 7 - Check Duplicated Camera on Structure",
    "section": "11.1 Common steps",
    "text": "11.1 Common steps\nWe use our customized read_sheet function to load the camera trap setup data from all available spreadsheets. Hence, we need to load the FUNCTIONS.R. Another function, also needed to create unique id’s called unique_id is loaded. Also, two special operators from the lubridate package are brought to the memory.\n\n\nCode\nsource(\"R/FUNCTIONS.R\")\n\nuse(\"lubridate\", c(\"%within%\", \"%--%\"))",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Step 7 - Check Duplicated Camera on Structure</span>"
    ]
  },
  {
    "objectID": "Quarto/07_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#data-loading",
    "href": "Quarto/07_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#data-loading",
    "title": "9  Step 7 - Check Duplicated Camera on Structure",
    "section": "11.2 Data Loading",
    "text": "11.2 Data Loading\nWe load the camera trap setup data (ct) and look for duplicated camera IDs within each structure.\n\n\nCode\n# Read camera trap setup data\nct &lt;- read_sheet(sheet = \"Camera_trap\", na = c(\"NA\", \"na\"))\n\nct |&gt;\n  head(2)\n\n\n$Alberto_Gonzalez\n# A tibble: 8 × 36\n  Structure_id Camera_id Camera_position Camera_view Camera_model   Camera_setup\n  &lt;chr&gt;        &lt;chr&gt;     &lt;chr&gt;           &lt;chr&gt;       &lt;chr&gt;          &lt;chr&gt;       \n1 PSF1         CAM63309  Interna central Interior    Pantheracam v… Secuencia d…\n2 PSF3         CAM63364  Interna central Interior    Pantheracam v… Secuencia d…\n3 PSF5         CAM63419  Interna central Interior    Pantheracam v… Secuencia d…\n4 PSF7         CAM63551  Interna central Interior    Pantheracam v… Secuencia d…\n5 PSF9         CAM63615  Interna central Interior    Pantheracam v… Secuencia d…\n6 PSF11        CAM63624  Interna central Interior    Pantheracam v… Secuencia d…\n7 PSF13        CAM63643  Interna central Interior    Pantheracam v… Secuencia d…\n8 PSF15        CAM63650  Borde interna   Interior    Pantheracam v… Secuencia d…\n# ℹ 30 more variables: Camera_vision_photo &lt;chr&gt;, Start_date &lt;dttm&gt;,\n#   Start_time &lt;dttm&gt;, End_date &lt;dttm&gt;, End_time &lt;dttm&gt;, Camera_problem &lt;chr&gt;,\n#   Problem1_from &lt;dttm&gt;, Problem1_to &lt;dttm&gt;, Problem2_from &lt;dttm&gt;,\n#   Problem2_to &lt;dttm&gt;, Problem3_from &lt;dttm&gt;, Problem3_to &lt;dttm&gt;,\n#   Problem4_from &lt;dttm&gt;, Problem4_to &lt;dttm&gt;, Problem5_from &lt;dttm&gt;,\n#   Problem5_to &lt;dttm&gt;, Problem6_from &lt;dttm&gt;, Problem6_to &lt;dttm&gt;,\n#   Problem7_from &lt;dttm&gt;, Problem7_to &lt;dttm&gt;, Problem8_from &lt;dttm&gt;, …\n\n$Ana_Delciellos\n# A tibble: 25 × 36\n   Structure_id Camera_id  Camera_position Camera_view Camera_model Camera_setup\n   &lt;chr&gt;        &lt;chr&gt;      &lt;chr&gt;           &lt;chr&gt;       &lt;chr&gt;        &lt;chr&gt;       \n 1 PNSB01       PNSB_cam1a Borda interna   Interior    Bushnell     Foto única  \n 2 PNSB01       PNSB_cam1b Borda interna   Interior    Bushnell     Foto única  \n 3 PNSB01       PNSB_cam1c Borda interna   Interior    Bushnell     Foto única  \n 4 PNSB01       PNSB_cam1d Borda interna   Interior    Bushnell     Vídeo       \n 5 PNSB01       PNSB_cam1e Borda interna   Interior    Bushnell     Foto única  \n 6 PNSB02       PNSB_cam2a Borda interna   Interior    Bushnell     Foto única  \n 7 PNSB02       PNSB_cam2b Borda interna   Interior    Bushnell     Foto única  \n 8 PNSB02       PNSB_cam2c Borda interna   Interior    Bushnell     Foto única  \n 9 PNSB03       PNSB_cam3a Borda interna   Interior    Bushnell     Foto única  \n10 PNSB03       PNSB_cam3b Borda interna   Interior    Bushnell     Foto única  \n# ℹ 15 more rows\n# ℹ 30 more variables: Camera_vision_photo &lt;chr&gt;, Start_date &lt;dttm&gt;,\n#   Start_time &lt;dttm&gt;, End_date &lt;dttm&gt;, End_time &lt;dttm&gt;, Camera_problem &lt;chr&gt;,\n#   Problem1_from &lt;dttm&gt;, Problem1_to &lt;dttm&gt;, Problem2_from &lt;dttm&gt;,\n#   Problem2_to &lt;dttm&gt;, Problem3_from &lt;dttm&gt;, Problem3_to &lt;dttm&gt;,\n#   Problem4_from &lt;dttm&gt;, Problem4_to &lt;dttm&gt;, Problem5_from &lt;dttm&gt;,\n#   Problem5_to &lt;dttm&gt;, Problem6_from &lt;dttm&gt;, Problem6_to &lt;dttm&gt;, …",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Step 7 - Check Duplicated Camera on Structure</span>"
    ]
  },
  {
    "objectID": "Quarto/07_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#identifying-duplicated-cameras",
    "href": "Quarto/07_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#identifying-duplicated-cameras",
    "title": "9  Step 7 - Check Duplicated Camera on Structure",
    "section": "11.3 Identifying Duplicated Cameras",
    "text": "11.3 Identifying Duplicated Cameras\nWe identify cases where the same camera ID appears more than once within the same structure.\n\n\nCode\nduplicated_cameras &lt;- ct |&gt; \n  purrr::map(~ .x |&gt; \n               dplyr::count(Structure_id, Camera_id) |&gt; \n               dplyr::filter(n &gt; 1)) |&gt; \n  purrr::discard(~ nrow(.x) == 0) |&gt; \n  dplyr::bind_rows(.id = \"Dataset\")\n\nduplicated_cameras |&gt;\n  head()\n\n\n# A tibble: 6 × 4\n  Dataset    Structure_id Camera_id     n\n  &lt;chr&gt;      &lt;chr&gt;        &lt;chr&gt;     &lt;int&gt;\n1 EGR_data02 T1-2         camT1-2       2\n2 EGR_data02 T1-3         camT1-3       2\n3 EGR_data02 T2-1         camT2-1       2\n4 EGR_data02 T2-2         camT2-2       2\n5 EGR_data02 T3-1         camT3-1       2\n6 EGR_data02 T3-3         camT3-3       2",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Step 7 - Check Duplicated Camera on Structure</span>"
    ]
  },
  {
    "objectID": "Quarto/07_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#handling-datasets-with-duplicates",
    "href": "Quarto/07_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#handling-datasets-with-duplicates",
    "title": "9  Step 7 - Check Duplicated Camera on Structure",
    "section": "11.4 Handling Datasets with Duplicates",
    "text": "11.4 Handling Datasets with Duplicates\nWe extract the datasets with duplicated cameras and apply the unique_id function to generate a column Camera_id with the new unique camera IDs. The old ID remains in Camera_id_orig field.\n\n\nCode\ndataset_dup_cameras &lt;- duplicated_cameras |&gt; \n  dplyr::distinct(Dataset) |&gt; \n  dplyr::pull(Dataset)\n\nct_with_dupes &lt;- ct[names(ct) %in% dataset_dup_cameras]\n\nct_uniq &lt;- ct_with_dupes |&gt; \n  purrr::map(~ unique_id(.x))\n\nct_uniq |&gt;\n  head(2)\n\n\n$EGR_data02\n# A tibble: 37 × 38\n   double Structure_id Camera_id Camera_id_orig Camera_position Camera_view\n    &lt;int&gt; &lt;chr&gt;        &lt;chr&gt;     &lt;chr&gt;          &lt;chr&gt;           &lt;chr&gt;      \n 1      3 T5-6         camT5-6_A camT5-6        Borda interna   Interior   \n 2      1 T5-7         camT5-7_A camT5-7_A      Borda interna   Interior   \n 3      2 T5-5         camT5-5_A camT5-5        Borda interna   Interior   \n 4      3 T5-6         camT5-6_B camT5-6        Borda interna   Interior   \n 5      2 T2-2         camT2-2_A camT2-2        Borda interna   Interior   \n 6      2 T2-2         camT2-2_B camT2-2        Borda interna   Interior   \n 7      2 T5-4         camT5-4_A camT5-4        Borda interna   Interior   \n 8      2 T5-2         camT5-2_A camT5-2        Borda interna   Interior   \n 9      2 T5-3         camT5-3_A camT5-3        Borda interna   Interior   \n10      2 T3-1         camT3-1_A camT3-1        Borda interna   Interior   \n# ℹ 27 more rows\n# ℹ 32 more variables: Camera_model &lt;chr&gt;, Camera_setup &lt;chr&gt;,\n#   Camera_vision_photo &lt;chr&gt;, Start_date &lt;dttm&gt;, Start_time &lt;dttm&gt;,\n#   End_date &lt;dttm&gt;, End_time &lt;dttm&gt;, Camera_problem &lt;chr&gt;,\n#   Problem1_from &lt;dttm&gt;, Problem1_to &lt;dttm&gt;, Problem2_from &lt;dttm&gt;,\n#   Problem2_to &lt;dttm&gt;, Problem3_from &lt;dttm&gt;, Problem3_to &lt;dttm&gt;,\n#   Problem4_from &lt;dttm&gt;, Problem4_to &lt;dttm&gt;, Problem5_from &lt;dttm&gt;, …\n\n$Marina_souza\n# A tibble: 90 × 38\n   double Structure_id Camera_id Camera_id_orig Camera_position Camera_view\n    &lt;int&gt; &lt;chr&gt;        &lt;chr&gt;     &lt;chr&gt;          &lt;chr&gt;           &lt;chr&gt;      \n 1      1 04_PT04      CT01      CT01           Externa         Abertura   \n 2      1 28_BSTC11    CT02      CT02           Externa         Abertura   \n 3      1 56_BDCC08    CT02      CT02           Externa         Abertura   \n 4      1 45_BDTC03    CT01      CT01           Externa         Abertura   \n 5      2 56_BDCC08    CB02_A    CB02           Externa         Interior   \n 6      1 52_BTTC01    CB03      CB03           Interna central Interior   \n 7      1 57_BSCC09    CB03      CB03           Externa         &lt;NA&gt;       \n 8      1 52_BTTC01    CB01      CB01           Interna central Interior   \n 9      1 56_BDCC08    CB04      CB04           Externa         Interior   \n10      1 52_BTTC01    CB02      CB02           Interna central Interior   \n# ℹ 80 more rows\n# ℹ 32 more variables: Camera_model &lt;chr&gt;, Camera_setup &lt;chr&gt;,\n#   Camera_vision_photo &lt;chr&gt;, Start_date &lt;dttm&gt;, Start_time &lt;dttm&gt;,\n#   End_date &lt;dttm&gt;, End_time &lt;dttm&gt;, Camera_problem &lt;chr&gt;,\n#   Problem1_from &lt;dttm&gt;, Problem1_to &lt;dttm&gt;, Problem2_from &lt;dttm&gt;,\n#   Problem2_to &lt;dttm&gt;, Problem3_from &lt;dttm&gt;, Problem3_to &lt;dttm&gt;,\n#   Problem4_from &lt;dttm&gt;, Problem4_to &lt;dttm&gt;, Problem5_from &lt;dttm&gt;, …",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Step 7 - Check Duplicated Camera on Structure</span>"
    ]
  },
  {
    "objectID": "Quarto/07_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#checking-for-remaining-duplicates",
    "href": "Quarto/07_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#checking-for-remaining-duplicates",
    "title": "9  Step 7 - Check Duplicated Camera on Structure",
    "section": "11.5 Checking for Remaining Duplicates",
    "text": "11.5 Checking for Remaining Duplicates\nWe check if any dataset still has more than one camera ID per structure after applying the unique ID function.\n\n\nCode\nct_uniq |&gt; \n  dplyr::bind_rows(.id = \"Dataset\") |&gt; \n  dplyr::count(Dataset, Structure_id, Camera_id) |&gt; \n  dplyr::filter(n &gt; 1) |&gt;\n  head(2)\n\n\n# A tibble: 0 × 4\n# ℹ 4 variables: Dataset &lt;chr&gt;, Structure_id &lt;chr&gt;, Camera_id &lt;chr&gt;, n &lt;int&gt;",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Step 7 - Check Duplicated Camera on Structure</span>"
    ]
  },
  {
    "objectID": "Quarto/07_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#cross-checking-with-species-records",
    "href": "Quarto/07_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#cross-checking-with-species-records",
    "title": "9  Step 7 - Check Duplicated Camera on Structure",
    "section": "11.6 Cross-checking with Species Records",
    "text": "11.6 Cross-checking with Species Records\nWe load the species records and cross-check them with the corrected camera trap data to ensure records are properly matched.\n\n\nCode\nrec &lt;- read_sheet(sheet = \"Species_records_camera\", na = c(\"NA\", \"na\")) |&gt; \n  purrr::map(\\(x) x |&gt; \n               dttm_update(\n                 date_col = \"Record_date\",\n                 time_col = \"Record_time\"\n               ) |&gt; \n               dplyr::select(-Record_time)\n  ) \n\nrec_with_dupes &lt;- rec[names(rec) %in% dataset_dup_cameras]\n\nrec_with_dupes |&gt; \n  head(2)\n\n\n$EGR_data02\n# A tibble: 1,178 × 6\n   Structure_id Camera_id Species   Record_date         Record_criteria Behavior\n   &lt;chr&gt;        &lt;chr&gt;     &lt;chr&gt;     &lt;dttm&gt;                        &lt;dbl&gt; &lt;chr&gt;   \n 1 T5-6         camT5-6   Didelphi… 2023-02-09 03:46:00              NA Travess…\n 2 T5-6         camT5-6   Didelphi… 2023-02-13 03:42:00              NA Travess…\n 3 T5-6         camT5-6   Didelphi… 2023-02-14 02:55:00              NA Travess…\n 4 T5-5         camT5-5   Rodentia  2023-03-08 19:57:00              NA Travess…\n 5 T5-5         camT5-5   Rodentia  2023-03-20 00:36:00              NA Travess…\n 6 T5-5         camT5-5   Rodentia  2023-03-26 22:47:00              NA Travess…\n 7 T5-6         camT5-6   Didelphi… 2023-02-17 01:24:00              NA Travess…\n 8 T5-6         camT5-6   Didelphi… 2023-02-18 01:15:00              NA Travess…\n 9 T5-6         camT5-6   Didelphi… 2023-02-25 00:05:00              NA Travess…\n10 T5-6         camT5-6   Didelphi… 2023-02-26 04:14:00              NA Travess…\n# ℹ 1,168 more rows\n\n$Marina_souza\n# A tibble: 226 × 6\n   Structure_id Camera_id Species   Record_date         Record_criteria Behavior\n   &lt;chr&gt;        &lt;chr&gt;     &lt;chr&gt;     &lt;dttm&gt;                        &lt;dbl&gt; &lt;chr&gt;   \n 1 05_BTCC01    CB02      Monodelp… 2020-02-23 23:21:49              NA Dentro  \n 2 05_BTCC01    CB04      Canis fa… 2020-05-30 12:35:53              NA Saindo  \n 3 05_BTCC01    CB04      Equus ca… 2020-05-30 11:39:09              NA Saindo  \n 4 11_BDCC02    CB04      Monodelp… 2020-02-23 22:33:41              NA Dentro  \n 5 11_BDCC02    CB04      Monodelp… 2020-02-24 22:21:31              NA Dentro  \n 6 11_BDCC02    CB04      Monodelp… 2020-02-25 02:06:06              NA Dentro  \n 7 11_BDCC02    CB04      Salvator… 2020-02-24 11:48:12              NA Entrando\n 8 11_BDCC02    CB06      Chiropte… 2020-05-29 21:41:18              NA Dentro  \n 9 11_BDCC02    CB01      Cerdocyo… 2020-11-28 18:05:46              NA Saindo  \n10 11_BDCC02    CB01      Bos taur… 2020-11-30 14:16:33              NA Saindo  \n# ℹ 216 more rows",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Step 7 - Check Duplicated Camera on Structure</span>"
    ]
  },
  {
    "objectID": "Quarto/07_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#output-generation",
    "href": "Quarto/07_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#output-generation",
    "title": "9  Step 7 - Check Duplicated Camera on Structure",
    "section": "11.7 Output Generation",
    "text": "11.7 Output Generation\nFor each dataset with duplicated cameras, we generate Excel files with the corrected camera trap data and the matched records. We also identify records that do not fall within any sampling interval.\n\n\nCode\nrows_with_errors &lt;- list()\n\nfor (dataset in dataset_dup_cameras) {\n  cam &lt;- ct_uniq[[dataset]] |&gt; \n    dplyr::mutate(code = stringr::str_glue(\"S{Structure_id}-C{Camera_id_orig}\"))\n  \n  reg &lt;- rec_with_dupes[[dataset]] |&gt; \n    tibble::rowid_to_column(\"id\") |&gt; \n    dplyr::mutate(code = stringr::str_glue(\"S{Structure_id}-C{Camera_id}\"))\n  \n  intermediate_result &lt;- reg |&gt; \n    dplyr::full_join(cam, by = \"code\", suffix = c(\"_rec\", \"\"), relationship = \"many-to-many\") |&gt; \n    dplyr::mutate(\n      dplyr::across(dplyr::ends_with(\"_time\"), ~ stringr::str_sub(., start = -8, end = -4)),\n      datetime_record = Record_date,\n      datetime_start = lubridate::ymd_hm(paste(\n        as.character(Start_date),\n        tidyr::replace_na(Start_time, \"00:00\")\n      )),\n      datetime_end = lubridate::ymd_hm(paste(\n        as.character(End_date),\n        tidyr::replace_na(End_time, \"00:00\")\n      )),\n      belongs_to = dplyr::if_else(\n        condition = datetime_record %within% c(datetime_start %--% datetime_end),\n        Camera_id,\n        \"nope\"\n      )\n    )\n  \n  intermediate_result |&gt; \n    dplyr::distinct(id, belongs_to, .keep_all = TRUE) |&gt; \n    dplyr::filter(!(dplyr::n() &gt; 1 & belongs_to == \"nope\"), .by = \"id\") |&gt; \n    dplyr::filter(!is.na(id)) |&gt; \n    head()\n  \n  rows_with_errors[[dataset]] &lt;- intermediate_result |&gt; \n    dplyr::filter(all(belongs_to == \"nope\"), .by = \"id\")\n}\n\nrows_with_errors |&gt; \n  dplyr::bind_rows(.id = \"dataset\") |&gt; \n  head()\n\n\n# A tibble: 6 × 51\n  dataset         id Structure_id_rec Camera_id_rec Species  Record_date        \n  &lt;chr&gt;        &lt;int&gt; &lt;chr&gt;            &lt;chr&gt;         &lt;chr&gt;    &lt;dttm&gt;             \n1 Marina_souza    37 17_BSTC04        CB08          Tropidu… 2018-10-01 15:29:04\n2 Marina_souza    43 18_BSTC05        CB07          Leopard… 2018-10-01 15:35:12\n3 Marina_souza    63 18_BSTC05        CB01          Sigmodo… 2019-03-21 21:53:58\n4 Marina_souza    64 18_BSTC05        CB01          Sigmodo… 2019-03-23 21:10:37\n5 Marina_souza    65 18_BSTC05        CB01          Chiropt… 2019-03-23 18:50:25\n6 Marina_souza    66 18_BSTC05        CB01          Sigmodo… 2019-03-24 03:17:27\n# ℹ 45 more variables: Record_criteria &lt;dbl&gt;, Behavior &lt;chr&gt;, code &lt;glue&gt;,\n#   double &lt;int&gt;, Structure_id &lt;chr&gt;, Camera_id &lt;chr&gt;, Camera_id_orig &lt;chr&gt;,\n#   Camera_position &lt;chr&gt;, Camera_view &lt;chr&gt;, Camera_model &lt;chr&gt;,\n#   Camera_setup &lt;chr&gt;, Camera_vision_photo &lt;chr&gt;, Start_date &lt;dttm&gt;,\n#   Start_time &lt;chr&gt;, End_date &lt;dttm&gt;, End_time &lt;chr&gt;, Camera_problem &lt;chr&gt;,\n#   Problem1_from &lt;dttm&gt;, Problem1_to &lt;dttm&gt;, Problem2_from &lt;dttm&gt;,\n#   Problem2_to &lt;dttm&gt;, Problem3_from &lt;dttm&gt;, Problem3_to &lt;dttm&gt;, …",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Step 7 - Check Duplicated Camera on Structure</span>"
    ]
  },
  {
    "objectID": "Quarto/07_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#results-interpretation",
    "href": "Quarto/07_CHECK_DUPLICATED_CAMERA_ON_STRUCTURE.html#results-interpretation",
    "title": "9  Step 7 - Check Duplicated Camera on Structure",
    "section": "11.8 Results Interpretation",
    "text": "11.8 Results Interpretation\nThe output files contain:\n\nCorrected camera trap data with unique camera IDs per structure.\nMatched species records with the corrected camera IDs.\nRecords that do not fall within any camera trap sampling interval.\n\nThis process ensures data consistency and helps identify potential issues with camera deployment or data entry.",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Step 7 - Check Duplicated Camera on Structure</span>"
    ]
  },
  {
    "objectID": "Quarto/00_PRESENTATION_FUNCTIONS.html#read_sheet",
    "href": "Quarto/00_PRESENTATION_FUNCTIONS.html#read_sheet",
    "title": "2  Step 0 - Creating customized functions",
    "section": "4.1 read_sheet",
    "text": "4.1 read_sheet\nOne the first steps of our datapaper was to create functions that are common to several other checks that we will perform.\nThe primary function concerns to reading the Excel files and their spreadsheets containing the data. Since some other checks didn’t need the results of the reading but only the names of the datasets and their paths, we created a function encompassing these issues. The function is called read_sheet.\n\n\nCode\nread_sheet &lt;- function(path = \"Excel\", sheet = NULL, na = \"\", results = TRUE) {\n  excel &lt;- list.files(\n    path = path,\n    pattern = \"^\\\\w.+xlsx$\",\n    full.names = TRUE,\n    recursive = TRUE\n  )\n\n  names &lt;- excel |&gt;\n    stringr::str_split(\"/|\\\\.\") |&gt;\n    purrr::map_vec(2)\n\n  load &lt;- excel |&gt;\n    purrr::set_names(names)\n\n  if (!results) {\n    return(load)\n  }\n\n  column_types &lt;- set_column_types(sheet = sheet)\n\n  result &lt;- load |&gt;\n    purrr::map(function(file) {\n      df &lt;- withCallingHandlers(\n        readxl::read_xlsx(\n          path = file,\n          sheet = sheet,\n          na = na,\n          col_names = TRUE,\n          col_types = column_types\n        )\n      ) |&gt;\n        janitor::remove_empty(\"rows\")\n\n      names(df) &lt;- df |&gt;\n        janitor::clean_names() |&gt;\n        colnames() |&gt;\n        stringr::str_to_sentence()\n\n      return(df)\n    })\n\n  return(result)\n}\n\n\nThe function has four arguments:\n\npath: the pattern was set to “Excel” as this is the folder where our files are stored.\nsheet: we put as NULL because we may not want to have the full results, therefore, there is no need to read the spreadsheets.\nna: to define what are the options to read NA. Default ““.\nresults: we may not want the results but only the paths for the datasets in customized functions (see Column Consistency).\n\nTo read the spreadsheets we need to list the files on the folder, by specifying which one is an Excel file. We ask R to return the full names, which include the full path of the file. For the sake of organization we also named the previous vector with the paths of the spreadsheets with the respective names of their main authors. Now we set the names of the paths with the author’s names extracted in last step.\nFirstly, we retrieve the full path of any .xlsx file found inside the “Excel” folder. The second step consists on splitting the full path into pieces and plucking the second element, as it represents the name of the dataset. Following, we name every full path with the name of the dataset. If we are reading the Excel files with a customized function, we stop here. If not, we read every Excel file of the list considering the sheet informed. The results comprise the name of the columns in a specific format, which is initiated by a capital letter followed by lowercase letters with the underscore separator for words.",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Step 0 - Creating customized functions</span>"
    ]
  },
  {
    "objectID": "Quarto/00_PRESENTATION_FUNCTIONS.html#unique_id",
    "href": "Quarto/00_PRESENTATION_FUNCTIONS.html#unique_id",
    "title": "2  Step 0 - Creating customized functions",
    "section": "4.2 unique_id",
    "text": "4.2 unique_id\nThe function takes two arguments:\n\nx: a data frame from the Camera_trap sheet.\n\nsep: a string (default \"_\") used to separate the original Camera_id from an appended letter when duplicates are found.\n\nInternally, it adds a helper column rowid with to preserve the original row order, then groups the data by Structure_id and Camera_id and counts how many times each pair appears into a column called double. Within each group it saves the original Camera_id as Camera_id_orig, assigns a sequential index Dup_id and constructs Dup_form_name: if double equals 1 it keeps the original Camera_id, otherwise it appends the separator and a letter from LETTERS based on Dup_id. After ungrouping, it selects the helper columns (rowid, Camera_id_orig, Dup_form_name, double) and left-joins them back onto the original data by rowid, then updates Camera_id to Dup_form_name when present, relocates Camera_id_orig immediately after Camera_id, and drops the temporary columns.\nThe practical effect is to ensure that within each Structure_id–Camera_id group any repeated camera IDs become unique by appending letters, while preserving the original ID in Camera_id_orig and returning the full updated data frame.\n\n\nCode\nunique_id &lt;- function(x, sep = \"_\") {\n  x_with_id &lt;- x |&gt;\n    tibble::rowid_to_column()\n  \n  x_with_id |&gt;\n    dplyr::group_by(Structure_id, Camera_id) |&gt;\n    dplyr::add_count(Structure_id, Camera_id, name = \"double\") |&gt;\n    dplyr::mutate(\n      Camera_id_orig = Camera_id,\n      Dup_id = dplyr::row_number(Camera_id),\n      Dup_form_name = dplyr::if_else(\n        condition = double == 1,\n        true = Camera_id,\n        false = stringr::str_c(Camera_id, sep, LETTERS[Dup_id])\n      )\n    ) |&gt;\n    dplyr::ungroup() |&gt;\n    dplyr::select(rowid, Camera_id_orig, Dup_form_name, double) |&gt;\n    dplyr::left_join(x_with_id, ., by = \"rowid\") |&gt;\n    dplyr::mutate(\n      Camera_id = dplyr::if_else(\n        !is.na(Dup_form_name),\n        Dup_form_name,\n        Camera_id\n      )\n    ) |&gt;\n    dplyr::relocate(Camera_id_orig, .after = Camera_id) |&gt;\n    dplyr::select(-Dup_form_name, -rowid)\n}",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Step 0 - Creating customized functions</span>"
    ]
  },
  {
    "objectID": "Quarto/00_PRESENTATION_FUNCTIONS.html#dttm_update",
    "href": "Quarto/00_PRESENTATION_FUNCTIONS.html#dttm_update",
    "title": "2  Step 0 - Creating customized functions",
    "section": "4.3 dttm_update",
    "text": "4.3 dttm_update\nThe function takes three arguments:\n\nx: a data frame containing date and time columns.\ndate_col: the name (string) of the column that stores the date part.\ntime_col: the name (string) of the column that stores the time part.\n\nInternally, we update the original date column using lubridate:::update_datetime(), combining the existing date with hours, minutes, and seconds extracted from the time column via lubridate::hour(), lubridate::minute(), and lubridate::second().\nThe practical effect is to merge the date information from one column with the time information from another, producing a complete datetime object in the specified date column and returning the updated data frame.\n\n\nCode\ndttm_update &lt;- function(x, date_col, time_col) {\n\n  date_sym &lt;- rlang::sym(date_col)\n  time_sym &lt;- rlang::sym(time_col)\n  \n  x |&gt;\n    dplyr::mutate(\n      !!date_sym := lubridate:::update_datetime(\n        !!date_sym,\n        hour = lubridate::hour(!!time_sym),\n        minute = lubridate::minute(!!time_sym),\n        second = lubridate::second(!!time_sym)\n      )\n    )\n}",
    "crumbs": [
      "Data Quality Checks",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Step 0 - Creating customized functions</span>"
    ]
  }
]